# The Modern C++ Challenge

- https://github.com/PacktPublishing/Modern-C-plus-plus-Efficient-and-Scalable-Application-Development

 - [Math Problems](#math-problems)
	- [1. Sum of naturals divisible by 3 and 5](#1-sum-of-naturals-divisible-by-3-and-5)
	- [2. Greatest common divisor](#2-greatest-common-divisor)
	- [3. Least common multiple](#3-least-common-multiple)
	- [4. Largest prime smaller than given number](#4-largest-prime-smaller-than-given-number)
	- [5. Sexy prime pairs](#5-sexy-prime-pairs)
	- [6. Abundant numbers](#6-abundant-numbers)
	- [7. Amicable numbers](#7-amicable-numbers)
	- [8. Armstrong numbers](#8-armstrong-numbers)
	- [9. Prime factors of a number](#9-prime-factors-of-a-number)
	- [10. Gray code](#10-gray-code)
	- [11. Converting numerical values to Roman](#11-converting-numerical-values-to-roman)
	- [12. Largest Collatz sequence](#12-largest-collatz-sequence)
	- [13. Computing the value of Pi](#13-computing-the-value-of-pi)
	- [14. Validating ISBNs](#14-validating-isbns)
- [Language Features](#language-features)
	- [15. IPv4 data type](#15-ipv4-data-type)
	- [16. Enumerating IPv4 addresses in a range](#16-enumerating-ipv4-addresses-in-a-range)
	- [17. Creating a 2D array with basic operations](#17-creating-a-2d-array-with-basic-operations)
	- [18. Minimum function with any number of arguments](#18-minimum-function-with-any-number-of-arguments)
	- [19. Adding a range of values to a container](#19-adding-a-range-of-values-to-a-container)
	- [20. Container any, all, none](#20-container-any-all-none)
	- [21. System handle wrapper](#21-system-handle-wrapper)
	- [22. Literals of various temperature scales](#22-literals-of-various-temperature-scales)
- [Strings and Regular Expressions](#strings-and-regular-expressions)
	- [23. Binary to string conversion](#23-binary-to-string-conversion)
	- [24. String to binary conversion](#24-string-to-binary-conversion)
	- [25. Capitalizing an article title](#25-capitalizing-an-article-title)
	- [26. Joining strings together separated by a delimiter](#26-joining-strings-together-separated-by-a-delimiter)
	- [27. Splitting a string into tokens with a list of possible delimiters](#27-splitting-a-string-into-tokens-with-a-list-of-possible-delimiters)
	- [28. Longest palindromic substring](#28-longest-palindromic-substring)
	- [29. License plate validation](#29-license-plate-validation)
	- [30. Extracting URL parts](#30-extracting-url-parts)
	- [31. Transforming dates in strings](#31-transforming-dates-in-strings)
- [Streams and Filesystems](#streams-and-filesystems)
	- [32. Pascal's triangle](#32-pascals-triangle)
	- [33. Tabular printing of a list of processes](#33-tabular-printing-of-a-list-of-processes)
	- [34. Removing empty lines from a text file](#34-removing-empty-lines-from-a-text-file)
	- [35. Computing the size of a directory](#35-computing-the-size-of-a-directory)
	- [36. Deleting files older than a given date](#36-deleting-files-older-than-a-given-date)
	- [37. Finding files in a directory that match a regular expression](#37-finding-files-in-a-directory-that-match-a-regular-expression)
	- [38. Temporary log files](#38-temporary-log-files)
- [Date and Time](#date-and-time)
	- [39. Measuring function execution time](#39-measuring-function-execution-time)
	- [40. Number of days between two dates](#40-number-of-days-between-two-dates)
	- [41. Day of the week](#41-day-of-the-week)
	- [42. Day and week of the year](#42-day-and-week-of-the-year)
	- [43. Meeting time for multiple time zones](#43-meeting-time-for-multiple-time-zones)
	- [44. Monthly calendar](#44-monthly-calendar)
- [Algorithms and Data Structures](#algorithms-and-data-structures)
	- [45. Priority queue](#45-priority-queue)
	- [46. Circular buffer](#46-circular-buffer)
	- [47. Double buffer](#47-double-buffer)
	- [48. The most frequent element in a range](#48-the-most-frequent-element-in-a-range)
	- [49. Text histogram](#49-text-histogram)
	- [50. Filtering a list of phone numbers](#50-filtering-a-list-of-phone-numbers)
	- [51. Transforming a list of phone numbers](#51-transforming-a-list-of-phone-numbers)
	- [52. Generating all the permutations of a string](#52-generating-all-the-permutations-of-a-string)
	- [53. Average rating of movies](#53-average-rating-of-movies)
	- [54. Pairwise algorithm](#54-pairwise-algorithm)
	- [55. Zip algorithm](#55-zip-algorithm)
	- [56. Select algorithm](#56-select-algorithm)
	- [57. Sort algorithm](#57-sort-algorithm)
	- [58. The shortest path between nodes](#58-the-shortest-path-between-nodes)
	- [59. The Weasel program](#59-the-weasel-program)
	- [60. The Game of Life](#60-the-game-of-life)
- [Concurrency](#concurrency)
	- [61. Parallel transform algorithm](#61-parallel-transform-algorithm)
	- [62. Parallel min and max element algorithms using threads](#62-parallel-min-and-max-element-algorithms-using-threads)
	- [63. Parallel min and max element algorithms using asynchronous functions](#63-parallel-min-and-max-element-algorithms-using-asynchronous-functions)
	- [64. Parallel sort algorithm](#64-parallel-sort-algorithm)
	- [65. Thread-safe logging to the console](#65-thread-safe-logging-to-the-console)
	- [66. Customer service system](#66-customer-service-system)
- [Design Patterns](#design-patterns)
	- [67. Validating passwords](#67-validating-passwords)
	- [68. Generating random passwords](#68-generating-random-passwords)
	- [69. Generating social security numbers](#69-generating-social-security-numbers)
	- [70. Approval system](#70-approval-system)
	- [71. Observable vector container](#71-observable-vector-container)
	- [72. Computing order price with discounts](#72-computing-order-price-with-discounts)
- [Data Serialization](#data-serialization)
	- [73. Serializing and deserializing data to or from XML](#73-serializing-and-deserializing-data-to-or-from-xml)
	- [74. Selecting data from XML using XPath](#74-selecting-data-from-xml-using-xpath)
	- [75. Serializing data to JSON](#75-serializing-data-to-json)
	- [76. Deserializing data from JSON](#76-deserializing-data-from-json)
	- [77. Printing a list of movies to a PDF](#77-printing-a-list-of-movies-to-a-pdf)
	- [78. Creating a PDF from a collection of images](#78-creating-a-pdf-from-a-collection-of-images)
- [Archives, Images, and Databases](#archives-images-and-databases)
	- [79. Finding files in a ZIP archive](#79-finding-files-in-a-zip-archive)
	- [80. Compressing and decompressing files to or from a ZIP archive](#80-compressing-and-decompressing-files-to-or-from-a-zip-archive)
	- [81. Compressing and decompressing files to or from a ZIP archive with a password](#81-compressing-and-decompressing-files-to-or-from-a-zip-archive-with-a-password)
	- [82. Creating a PNG that represents a national flag](#82-creating-a-png-that-represents-a-national-flag)
	- [83. Creating verification text PNG images](#83-creating-verification-text-png-images)
	- [84. EAN-13 barcode generator](#84-ean-13-barcode-generator)
	- [85. Reading movies from an SQLite database](#85-reading-movies-from-an-sqlite-database)
	- [86. Inserting movies into an SQLite database transactionally](#86-inserting-movies-into-an-sqlite-database-transactionally)
	- [87. Handling movie images in an SQLite database](#87-handling-movie-images-in-an-sqlite-database)
- [Cryptography](#cryptography)
	- [88. Caesar cipher](#88-caesar-cipher)
	- [89. Vigenère cipher](#89-vigenère-cipher)
	- [90. Base64 encoding and decoding](#90-base64-encoding-and-decoding)
	- [91. Validating user credentials](#91-validating-user-credentials)
	- [92. Computing file hashes](#92-computing-file-hashes)
	- [93. Encrypting and decrypting files](#93-encrypting-and-decrypting-files)
	- [94. File signing](#94-file-signing)
- [Networking and Services](#networking-and-services)
	- [95. Finding the IP address of a host](#95-finding-the-ip-address-of-a-host)
	- [96. Client-server Fizz-Buzz](#96-client-server-fizz-buzz)
	- [97. Bitcoin exchange rates](#97-bitcoin-exchange-rates)
	- [98. Fetching emails using IMAP](#98-fetching-emails-using-imap)
	- [99. Translating text to any language](#99-translating-text-to-any-language)
	- [100. Detecting faces in a picture](#100-detecting-faces-in-a-picture)

## Math Problems

### 1. Sum of naturals divisible by 3 and 5

```c++

#include <iostream>
int main() {
  unsigned int limit = 0;
  std::cout << "Upper limit:";
  std::cin >> limit;
  unsigned long long sum = 0;
  for (unsigned int i = 3; i < limit; ++i) {
    if (i % 3 == 0 || i % 5 == 0)
      sum += i;
  }
  std::cout << "sum=" << sum << std::endl;
}
```

### 2. Greatest common divisor

```c++

#include <iostream>
unsigned int gcd(unsigned int const a, unsigned int const b) {
  return b == 0 ? a : gcd(b, a % b);
}
unsigned int gcd2(unsigned int a, unsigned int b) {
  while (b != 0) {
    unsigned int r = a % b;
    a = b;
    b = r;
  }
  return a;
}
int main() {
  std::cout << "Input numbers:";
  unsigned int a, b;
  std::cin >> a >> b;
  std::cout << "rec gcd(" << a << ", " << b << ")=" << gcd(a, b) << std::endl;
  std::cout << "    gcd(" << a << ", " << b << ")=" << gcd2(a, b) << std::endl;
}
```

### 3. Least common multiple

```c++

#include <iostream>
#include <numeric>
#include <vector>
int gcd(int const a, int const b) { return b == 0 ? a : gcd(b, a % b); }
int lcm(int const a, int const b) {
  int h = gcd(a, b);
  return h ? (a * (b / h)) : 0;
}
template <class InputIt> int lcmr(InputIt first, InputIt last) {
  return std::accumulate(first, last, 1, lcm);
}
int main() {
  int n = 0;
  std::cout << "Input count:";
  std::cin >> n;
  std::vector<int> numbers;
  for (int i = 0; i < n; ++i) {
    int v{0};
    std::cin >> v;
    numbers.push_back(v);
  }
  std::cout << "lcm=" << lcmr(std::begin(numbers), std::end(numbers))
            << std::endl;
}
```

### 4. Largest prime smaller than given number

```c++

#include <iostream>
bool is_prime(int const num) {
  if (num <= 3) {
    return num > 1;
  } else if (num % 2 == 0 || num % 3 == 0) {
    return false;
  } else {
    for (int i = 5; i * i <= num; i += 6) {
      if (num % i == 0 || num % (i + 2) == 0) {
        return false;
      }
    }
    return true;
  }
}
int main() {
  int limit = 0;
  std::cout << "Upper limit:";
  std::cin >> limit;
  for (int i = limit; i > 1; i--) {
    if (is_prime(i)) {
      std::cout << "Largest prime:" << i << std::endl;
      return 0;
    }
  }
}
```

### 5. Sexy prime pairs

```c++

#include <iostream>
bool is_prime(int const num) {
  if (num <= 3) {
    return num > 1;
  } else if (num % 2 == 0 || num % 3 == 0) {
    return false;
  } else {
    for (int i = 5; i * i <= num; i += 6) {
      if (num % i == 0 || num % (i + 2) == 0) {
        return false;
      }
    }
    return true;
  }
}
int main() {
  int limit = 0;
  std::cout << "Upper limit:";
  std::cin >> limit;
  for (int n = 2; n <= limit; n++) {
    if (is_prime(n) && is_prime(n + 6)) {
      std::cout << n << "," << n + 6 << std::endl;
    }
  }
}
```

### 6. Abundant numbers

```c++

#include <iostream>
#include <cmath>
int sum_proper_divisors(int const number) {
  int result = 1;
  for (int i = 2; i <= std::sqrt(number); i++) {
    if (number % i == 0) {
      result += (i == (number / i)) ? i : (i + number / i);
    }
  }
  return result;
}
void print_abundant(int const limit) {
  for (int number = 10; number <= limit; ++number) {
    auto sum = sum_proper_divisors(number);
    if (sum > number) {
      std::cout << number << ", abundance=" << sum - number << std::endl;
    }
  }
}
int main() {
  int limit = 0;
  std::cout << "Upper limit:";
  std::cin >> limit;
  print_abundant(limit);
}
```

### 7. Amicable numbers

```c++

#include <iostream>
#include <set>
#include <cmath>
int sum_proper_divisors(int const number) {
  int result = 1;
  for (int i = 2; i <= std::sqrt(number); i++) {
    if (number % i == 0) {
      result += (i == (number / i)) ? i : (i + number / i);
    }
  }
  return result;
}
void print_amicables(int const limit) {
  for (int number = 4; number < limit; ++number) {
    auto sum1 = sum_proper_divisors(number);
    if (sum1 < limit) {
      auto sum2 = sum_proper_divisors(sum1);
      if (sum2 == number && number != sum1) {
        std::cout << number << "," << sum1 << std::endl;
      }
    }
  }
}
void print_amicables_once(int const limit) {
  std::set<int> printed;
  for (int number = 4; number < limit; ++number) {
    if (printed.find(number) != printed.end())
      continue;
    auto sum1 = sum_proper_divisors(number);
    if (sum1 < limit) {
      auto sum2 = sum_proper_divisors(sum1);
      if (sum2 == number && number != sum1) {
        printed.insert(number);
        printed.insert(sum1);
        std::cout << number << "," << sum1 << std::endl;
      }
    }
  }
}
int main() {
  print_amicables(1000000);
  print_amicables_once(1000000);
}
```

### 8. Armstrong numbers

```c++

#include <iostream>
#include <vector>
#include <numeric>
#include <cmath>
#include <chrono>
#include <functional>
template <typename Time = std::chrono::microseconds,
          typename Clock = std::chrono::high_resolution_clock>
struct perf_timer {
  template <typename F, typename... Args>
  static Time duration(F &&f, Args... args) {
    auto start = Clock::now();
    std::invoke(std::forward<F>(f), std::forward<Args>(args)...);
    auto end = Clock::now();
    return std::chrono::duration_cast<Time>(end - start);
  }
};
void print_narcissistics_1(bool const printResults) {
  for (int a = 1; a <= 9; a++) {
    for (int b = 0; b <= 9; b++) {
      for (int c = 0; c <= 9; c++) {
        auto abc = a * 100 + b * 10 + c;
        auto arm = a * a * a + b * b * b + c * c * c;
        if (abc == arm) {
          if (printResults)
            std::cout << arm << std::endl;
        }
      }
    }
  }
}
void print_narcissistics_2(bool const printResults) {
  for (int i = 100; i <= 1000; ++i) {
    int arm = 0;
    int n = i;
    while (n > 0) {
      auto d = n % 10;
      n = n / 10;
      arm += d * d * d;
    }
    if (i == arm) {
      if (printResults)
        std::cout << arm << std::endl;
    }
  }
}
void print_narcissistics_3(int const limit, bool const printResults) {
  for (int i = 1; i <= limit; ++i) {
    std::vector<int> digits;
    int n = i;
    while (n > 0) {
      digits.push_back(n % 10);
      n = n / 10;
    }
    int arm =
        std::accumulate(std::begin(digits), std::end(digits), 0,
                        [s = digits.size()](int const sum, int const digit) {
                          return sum + static_cast<int>(std::pow(digit, s));
                        });
    if (i == arm) {
      if (printResults)
        std::cout << arm << std::endl;
    }
  }
}
int main() {
  print_narcissistics_1(true);
  print_narcissistics_2(true);
  print_narcissistics_3(1000, true);
  auto t1 = perf_timer<>::duration([]() {
    for (int i = 0; i < 10000; ++i)
      print_narcissistics_1(false);
  });
  std::cout << std::chrono::duration<double, std::milli>(t1).count() << "ms"
            << std::endl;
  auto t2 = perf_timer<>::duration([]() {
    for (int i = 0; i < 10000; ++i)
      print_narcissistics_2(false);
  });
  std::cout << std::chrono::duration<double, std::milli>(t2).count() << "ms"
            << std::endl;
  auto t3 = perf_timer<>::duration([]() {
    for (int i = 0; i < 10000; ++i)
      print_narcissistics_3(1000, false);
  });
  std::cout << std::chrono::duration<double, std::milli>(t3).count() << "ms"
            << std::endl;
}
```

### 9. Prime factors of a number

```c++

#include <iostream>
#include <cmath>
#include <vector>
#include <iterator>
#include <algorithm>
std::vector<unsigned long long> prime_factors(unsigned long long n) {
  std::vector<unsigned long long> factors;
  while (n % 2 == 0) {
    factors.push_back(2);
    n = n / 2;
  }
  for (unsigned long long i = 3; i <= std::sqrt(n); i += 2) {
    while (n % i == 0) {
      factors.push_back(i);
      n = n / i;
    }
  }
  if (n > 2)
    factors.push_back(n);
  return factors;
}
int main() {
  unsigned long long number = 0;
  std::cout << "number:";
  std::cin >> number;
  auto factors = prime_factors(number);
  std::copy(std::begin(factors), std::end(factors),
            std::ostream_iterator<unsigned long long>(std::cout, " "));
}
```
### 10. Gray code

```c++

#include <iostream>
#include <bitset>
#include <string>
unsigned int gray_encode(unsigned int const num) { return num ^ (num >> 1); }
unsigned int gray_decode(unsigned int gray) {
  for (unsigned int bit = 1U << 31; bit > 1; bit >>= 1) {
    if (gray & bit)
      gray ^= bit >> 1;
  }
  return gray;
}
std::string to_binary(unsigned int value, int const digits) {
  return std::bitset<32>(value).to_string().substr(32 - digits, digits);
}
int main() {
  std::cout << "Number\tBinary\tGray\tDecoded\n";
  std::cout << "------\t------\t----\t-------\n";
  for (unsigned int n = 0; n < 32; ++n) {
    auto encg = gray_encode(n);
    auto decg = gray_decode(encg);
    std::cout << n << "\t" << to_binary(n, 5) << "\t" << to_binary(encg, 5)
              << "\t" << decg << "\n";
  }
}
```

### 11. Converting numerical values to Roman

```c++

#include <iostream>
#include <string>
#include <vector>
std::string to_roman(unsigned int value) {
  std::vector<std::pair<unsigned int, char const *>> roman{
      {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"}, {100, "C"},
      {90, "XC"},  {50, "L"},   {40, "XL"}, {10, "X"},   {9, "IX"},
      {5, "V"},    {4, "IV"},   {1, "I"}};
  std::string result;
  for (auto const &kvp : roman) {
    while (value >= kvp.first) {
      result += kvp.second;
      value -= kvp.first;
    }
  }
  return result;
}
int main() {
  for (int i = 1; i <= 100; ++i) {
    std::cout << i << "\t" << to_roman(i) << std::endl;
  }
  int number = 0;
  std::cout << "number:";
  std::cin >> number;
  std::cout << to_roman(number) << std::endl;
}
```

### 12. Largest Collatz sequence

```c++

#include <iostream>
#include <vector>
std::pair<unsigned long long, long>
longest_collatz_uncached(unsigned long long const limit) {
  long length = 0;
  unsigned long long number = 0;
  for (unsigned long long i = 2; i <= limit; i++) {
    auto n = i;
    long steps = 0;
    while (n != 1) {
      if ((n % 2) == 0)
        n = n / 2;
      else
        n = n * 3 + 1;
      steps++;
    }
    if (steps > length) {
      length = steps;
      number = i;
    }
  }
  return std::make_pair(number, length);
}
std::pair<unsigned long long, long>
longest_collatz(unsigned long long const limit) {
  long length = 0;
  unsigned long long number = 0;
  std::vector<int> cache(limit + 1, 0);
  for (unsigned long long i = 2; i <= limit; i++) {
    auto n = i;
    long steps = 0;
    while (n != 1 && n >= i) {
      if ((n % 2) == 0)
        n = n / 2;
      else
        n = n * 3 + 1;
      steps++;
    }
    cache[i] = steps + cache[n];
    if (cache[i] > length) {
      length = cache[i];
      number = i;
    }
  }
  return std::make_pair(number, length);
}
int main() {
  struct test_data {
    unsigned long long limit;
    unsigned long long start;
    long steps;
  };
  std::vector<test_data> data{{10ULL, 9ULL, 19},
                              {100ULL, 97ULL, 118},
                              {1000ULL, 871ULL, 178},
                              {10000ULL, 6171ULL, 263},
                              {100000ULL, 77031ULL, 350},
                              {1000000ULL, 837799ULL, 524},
                              {10000000ULL, 8400511ULL, 685},
                              {100000000ULL, 63728127ULL, 949}};
  for (auto const &d : data) {
    auto result = longest_collatz(d.limit);
    if (result.first != d.start || result.second != d.steps)
      std::cout << "error on limit " << d.limit << std::endl;
    else
      std::cout << "less than      : " << d.limit << std::endl
                << "starting number: " << result.first << std::endl
                << "sequence length: " << result.second << std::endl;
  }
}
```

### 13. Computing the value of Pi

```c++

#include <iostream>
#include <random>
#include <algorithm>
#include <array>
#include <functional>
template <typename E = std::mt19937,
          typename D = std::uniform_real_distribution<>>
double compute_pi(E &engine, D &dist, int const samples = 1000000) {
  auto hit = 0;
  for (auto i = 0; i < samples; i++) {
    auto x = dist(engine);
    auto y = dist(engine);
    if (y <= std::sqrt(1 - std::pow(x, 2)))
      hit += 1;
  }
  return 4.0 * hit / samples;
}
int main() {
  std::random_device rd;
  auto seed_data = std::array<int, std::mt19937::state_size>{};
  std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
  std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
  auto eng = std::mt19937{seq};
  auto dist = std::uniform_real_distribution<>{0, 1};
  for (auto j = 0; j < 10; j++) {
    std::cout << compute_pi(eng, dist) << std::endl;
  }
}
```

### 14. Validating ISBNs

```c++

#include <iostream>
#include <string>
#include <algorithm>
#include <numeric>
#include <string_view>
#include <assert.h>
bool validate_isbn_10(std::string_view isbn) {
  auto valid = false;
  if (isbn.size() == 10 &&
      std::count_if(std::begin(isbn), std::end(isbn), isdigit) == 10) {
    auto w = 10;
    auto sum = std::accumulate(std::begin(isbn), std::end(isbn), 0,
                               [&w](int const total, char const c) {
                                 return total + w-- * (c - '0');
                               });
    valid = !(sum % 11);
  }
  return valid;
}
int main() {
  assert(validate_isbn_10("0306406152"));
  assert(!validate_isbn_10("0306406151"));
  std::string isbn;
  std::cout << "isbn:";
  std::cin >> isbn;
  std::cout << "valid: " << validate_isbn_10(isbn) << std::endl;
}
```

## Language Features

### 15. IPv4 data type

```c++

#include <iostream>
#include <array>
#include <sstream>
#include <assert.h>
class ipv4 {
  std::array<unsigned char, 4> data;
public:
  constexpr ipv4() : data{{0}} {}
  constexpr ipv4(unsigned char const a, unsigned char const b,
                 unsigned char const c, unsigned char const d)
      : data{{a, b, c, d}} {}
  explicit constexpr ipv4(unsigned long a)
      : data{{static_cast<unsigned char>((a >> 24) & 0xFF),
              static_cast<unsigned char>((a >> 16) & 0xFF),
              static_cast<unsigned char>((a >> 8) & 0xFF),
              static_cast<unsigned char>(a & 0xFF)}} {}
  ipv4(ipv4 const &other) noexcept : data(other.data) {}
  ipv4 &operator=(ipv4 const &other) noexcept {
    data = other.data;
    return *this;
  }
  std::string to_string() const {
    std::stringstream sstr;
    sstr << *this;
    return sstr.str();
  }
  constexpr unsigned long to_ulong() const noexcept {
    return (static_cast<unsigned long>(data[0]) << 24) |
           (static_cast<unsigned long>(data[1]) << 16) |
           (static_cast<unsigned long>(data[2]) << 8) |
           static_cast<unsigned long>(data[3]);
  }
  friend std::ostream &operator<<(std::ostream &os, const ipv4 &a) {
    os << static_cast<int>(a.data[0]) << '.' << static_cast<int>(a.data[1])
       << '.' << static_cast<int>(a.data[2]) << '.'
       << static_cast<int>(a.data[3]);
    return os;
  }
  friend std::istream &operator>>(std::istream &is, ipv4 &a) {
    char d1, d2, d3;
    int b1, b2, b3, b4;
    is >> b1 >> d1 >> b2 >> d2 >> b3 >> d3 >> b4;
    if (d1 == '.' && d2 == '.' && d3 == '.')
      a = ipv4(b1, b2, b3, b4);
    else
      is.setstate(std::ios_base::failbit);
    return is;
  }
};
int main() {
  ipv4 a(168, 192, 0, 1);
  std::cout << a << std::endl;
  std::cout << a.to_string() << std::endl;
  ipv4 b = a;
  ipv4 c;
  c = b;
  ipv4 ip;
  std::cout << ip << std::endl;
  std::cin >> ip;
  if (!std::cin.fail())
    std::cout << ip << std::endl;
}
```

### 16. Enumerating IPv4 addresses in a range

```c++

#include <iostream>
#include <array>
#include <sstream>
class ipv4 {
  std::array<unsigned char, 4> data;
public:
  constexpr ipv4() : data{{0}} {}
  constexpr ipv4(unsigned char const a, unsigned char const b,
                 unsigned char const c, unsigned char const d)
      : data{{a, b, c, d}} {}
  explicit constexpr ipv4(unsigned long a)
      : data{{static_cast<unsigned char>((a >> 24) & 0xFF),
              static_cast<unsigned char>((a >> 16) & 0xFF),
              static_cast<unsigned char>((a >> 8) & 0xFF),
              static_cast<unsigned char>(a & 0xFF)}} {}
  ipv4(ipv4 const &other) noexcept : data(other.data) {}
  ipv4 &operator=(ipv4 const &other) noexcept {
    data = other.data;
    return *this;
  }
  constexpr unsigned long to_ulong() const noexcept {
    return (static_cast<unsigned long>(data[0]) << 24) |
           (static_cast<unsigned long>(data[1]) << 16) |
           (static_cast<unsigned long>(data[2]) << 8) |
           static_cast<unsigned long>(data[3]);
  }
  std::string to_string() const {
    std::stringstream sstr;
    sstr << *this;
    return sstr.str();
  }
  constexpr bool is_loopback() const noexcept {
    return (to_ulong() & 0xFF000000) == 0x7F000000;
  }
  constexpr bool is_unspecified() const noexcept { return to_ulong() == 0; }
  constexpr bool is_class_a() const noexcept {
    return (to_ulong() & 0x80000000) == 0;
  }
  constexpr bool is_class_b() const noexcept {
    return (to_ulong() & 0xC0000000) == 0x80000000;
  }
  constexpr bool is_class_c() const noexcept {
    return (to_ulong() & 0xE0000000) == 0xC0000000;
  }
  constexpr bool is_multicast() const noexcept {
    return (to_ulong() & 0xF0000000) == 0xE0000000;
  }
  ipv4 &operator++() {
    *this = ipv4(1 + to_ulong());
    return *this;
  }
  ipv4 &operator++(int) {
    ipv4 result(*this);
    ++(*this);
    return *this;
  }
  friend bool operator==(ipv4 const &a1, ipv4 const &a2) noexcept {
    return a1.data == a2.data;
  }
  friend bool operator!=(ipv4 const &a1, ipv4 const &a2) noexcept {
    return !(a1 == a2);
  }
  friend bool operator<(ipv4 const &a1, ipv4 const &a2) noexcept {
    return a1.to_ulong() < a2.to_ulong();
  }
  friend bool operator>(ipv4 const &a1, ipv4 const &a2) noexcept {
    return a2 < a1;
  }
  friend bool operator<=(ipv4 const &a1, ipv4 const &a2) noexcept {
    return !(a1 > a2);
  }
  friend bool operator>=(ipv4 const &a1, ipv4 const &a2) noexcept {
    return !(a1 < a2);
  }
  friend std::ostream &operator<<(std::ostream &os, const ipv4 &a) {
    os << static_cast<int>(a.data[0]) << '.' << static_cast<int>(a.data[1])
       << '.' << static_cast<int>(a.data[2]) << '.'
       << static_cast<int>(a.data[3]);
    return os;
  }
  friend std::istream &operator>>(std::istream &is, ipv4 &a) {
    char d1, d2, d3;
    int b1, b2, b3, b4;
    is >> b1 >> d1 >> b2 >> d2 >> b3 >> d3 >> b4;
    if (d1 == '.' && d2 == '.' && d3 == '.')
      a = ipv4(b1, b2, b3, b4);
    else
      is.setstate(std::ios_base::failbit);
    return is;
  }
};
int main() {
  std::cout << "input range: ";
  ipv4 a1, a2;
  std::cin >> a1 >> a2;
  if (a2 > a1) {
    for (ipv4 a = a1; a <= a2; a++) {
      std::cout << a << std::endl;
    }
  } else {
    std::cerr << "invalid range!" << std::endl;
  }
}
```

### 17. Creating a 2D array with basic operations

```c++

#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
template <class T, size_t R, size_t C> class array2d {
  typedef T value_type;
  typedef value_type *iterator;
  typedef value_type const *const_iterator;
  std::vector<T> arr;
public:
  array2d() : arr(R * C) {}
  explicit array2d(std::initializer_list<T> l) : arr(l) {}
  constexpr T *data() noexcept { return arr.data(); }
  constexpr T const *data() const noexcept { return arr.data(); }
  constexpr T &at(size_t const r, size_t const c) { return arr.at(r * C + c); }
  constexpr T const &at(size_t const r, size_t const c) const {
    return arr.at(r * C + c);
  }
  constexpr T &operator()(size_t const r, size_t const c) {
    return arr[r * C + c];
  }
  constexpr T const &operator()(size_t const r, size_t const c) const {
    return arr[r * C + c];
  }
  constexpr bool empty() const noexcept { return R == 0 || C == 0; }
  constexpr size_t size(int const rank) const {
    if (rank == 1)
      return R;
    else if (rank == 2)
      return C;
    throw std::out_of_range("Rank is out of range!");
  }
  void fill(T const &value) {
    std::fill(std::begin(arr), std::end(arr), value);
  }
  void swap(array2d &other) noexcept { arr.swap(other.arr); }
  const_iterator begin() const { return arr.data(); }
  const_iterator end() const { return arr.data() + arr.size(); }
  iterator begin() { return arr.data(); }
  iterator end() { return arr.data() + arr.size(); }
};
template <class T, size_t R, size_t C>
void print_array2d(array2d<T, R, C> const &arr) {
  for (int i = 0; i < R; ++i) {
    for (int j = 0; j < C; ++j) {
      std::cout << arr.at(i, j) << ' ';
    }
    std::cout << std::endl;
  }
}
int main() {
  {
    std::cout << "test fill" << std::endl;
    array2d<int, 2, 3> a;
    a.fill(1);
    print_array2d(a);
  }
  {
    std::cout << "test operator()" << std::endl;
    array2d<int, 2, 3> a;
    for (size_t i = 0; i < a.size(1); ++i) {
      for (size_t j = 0; j < a.size(2); ++j) {
        a(i, j) = 1 + i * 3 + j;
      }
    }
    print_array2d(a);
  }
  {
    std::cout << "test move semantics" << std::endl;
    array2d<int, 2, 3> a{10, 20, 30, 40, 50, 60};
    print_array2d(a);
    array2d<int, 2, 3> b(std::move(a));
    print_array2d(b);
  }
  {
    std::cout << "test swap" << std::endl;
    array2d<int, 2, 3> a{1, 2, 3, 4, 5, 6};
    array2d<int, 2, 3> b{10, 20, 30, 40, 50, 60};
    print_array2d(a);
    print_array2d(b);
    a.swap(b);
    print_array2d(a);
    print_array2d(b);
  }
  {
    std::cout << "test capacity" << std::endl;
    array2d<int, 2, 3> const a{1, 2, 3, 4, 5, 6};
    for (size_t i = 0; i < a.size(1); ++i) {
      for (size_t j = 0; j < a.size(2); ++j) {
        std::cout << a(i, j) << ' ';
      }
      std::cout << std::endl;
    }
  }
  {
    std::cout << "test iterators" << std::endl;
    array2d<int, 2, 3> const a{1, 2, 3, 4, 5, 6};
    for (auto const e : a) {
      std::cout << e << ' ';
    }
    std::cout << std::endl;
    std::copy(std::begin(a), std::end(a),
              std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
  }
}
```

### 18. Minimum function with any number of arguments

```c++

#include <iostream>
#include <functional>
template <typename T> T minimum(T const a, T const b) { return a < b ? a : b; }
template <typename T1, typename... T> T1 minimum(T1 a, T... args) {
  return minimum(a, minimum(args...));
}
template <class Compare, typename T>
T minimumc(Compare comp, T const a, T const b) {
  return comp(a, b) ? a : b;
}
template <class Compare, typename T1, typename... T>
T1 minimumc(Compare comp, T1 a, T... args) {
  return minimumc(comp, a, minimumc(comp, args...));
}
int main() {
  auto x = minimum(5, 4, 2, 3);
  std::cout << x << std::endl;
  auto y = minimumc(std::less<>(), 3, 2, 1, 0);
  std::cout << y << std::endl;
}
```

### 19. Adding a range of values to a container

```c++

#include <iostream>
#include <cstdlib>
#include <vector>
#include <iterator>
#include <list>
template <typename C, typename... Args> void push_back(C &c, Args &&... args) {
  (c.push_back(args), ...);
}
int main() {
  std::vector<int> v;
  push_back(v, 1, 2, 3, 4);
  std::copy(std::begin(v), std::end(v),
            std::ostream_iterator<int>(std::cout, " "));
  std::list<int> l;
  push_back(l, 1, 2, 3, 4);
  std::copy(std::begin(l), std::end(l),
            std::ostream_iterator<int>(std::cout, " "));
}
```

### 20. Container any, all, none

```c++

#include <iostream>
#include <vector>
#include <array>
#include <list>
#include <assert.h>
#include <functional>
template <class C, class T> bool contains(C const &c, T const &value) {
  return std::end(c) != std::find(std::begin(c), std::end(c), value);
}
template <class C, class... T> bool contains_any(C const &c, T &&... value) {
  return (... || contains(c, value));
}
template <class C, class... T> bool contains_all(C const &c, T &&... value) {
  return (... && contains(c, value));
}
template <class C, class... T> bool contains_none(C const &c, T &&... value) {
  return !contains_any(c, std::forward<T>(value)...);
}
int main() {
  std::vector<int> v{1, 2, 3, 4, 5, 6};
  std::array<int, 6> a{{1, 2, 3, 4, 5, 6}};
  std::list<int> l{1, 2, 3, 4, 5, 6};
  assert(contains(v, 3));
  assert(contains(a, 3));
  assert(contains(l, 3));
  assert(!contains(v, 30));
  assert(!contains(v, 30));
  assert(!contains(v, 30));
  assert(contains_any(v, 0, 3, 30));
  assert(contains_any(a, 0, 3, 30));
  assert(contains_any(l, 0, 3, 30));
  assert(!contains_any(v, 0, 30));
  assert(!contains_any(a, 0, 30));
  assert(!contains_any(l, 0, 30));
  assert(contains_all(v, 1, 3, 6));
  assert(contains_all(a, 1, 3, 6));
  assert(contains_all(l, 1, 3, 6));
  assert(!contains_all(v, 0, 1));
  assert(!contains_all(a, 0, 1));
  assert(!contains_all(l, 0, 1));
  assert(contains_none(v, 0, 7));
  assert(contains_none(a, 0, 7));
  assert(contains_none(l, 0, 7));
  assert(!contains_none(v, 0, 6, 7));
  assert(!contains_none(a, 0, 6, 7));
  assert(!contains_none(l, 0, 6, 7));
}
```

### 21. System handle wrapper

```c++

#ifdef _WIN32
#include <windows.h>
#else
typedef void *HANDLE;
#define DWORD unsigned long
#ifdef _LP64
#define LONG_PTR long long
#define ULONG_PTR unsigned long long
#else
#define LONG_PTR long
#define ULONG_PTR unsigned long
#endif
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
struct SECURITY_ATTRIBUTES {
  DWORD nLength;
  void *lpSecurityDescriptor;
  int bInheritHandle;
};
struct OVERLAPPED {
  ULONG_PTR Internal;
  ULONG_PTR InternalHigh;
  union {
    struct {
      DWORD Offset;
      DWORD OffsetHigh;
    } DUMMYSTRUCTNAME;
    void *Pointer;
  } DUMMYUNIONNAME;
  HANDLE hEvent;
};
int CloseHandle(HANDLE hObject) { return 0; }
HANDLE CreateFile(char const *, DWORD, DWORD, SECURITY_ATTRIBUTES *, DWORD,
                  DWORD, HANDLE) {
  return INVALID_HANDLE_VALUE;
}
int ReadFile(HANDLE, void *, DWORD, DWORD *, OVERLAPPED *) { return 0; }
#define GENERIC_READ 0x80000000L
#define GENERIC_WRITE 0x40000000L
#define CREATE_NEW 1
#define CREATE_ALWAYS 2
#define OPEN_EXISTING 3
#define OPEN_ALWAYS 4
#define TRUNCATE_EXISTING 5
#define FILE_SHARE_READ 1
#define FILE_ATTRIBUTE_NORMAL 0x00000080
#endif
#include <algorithm>
#include <vector>
#include <stdexcept> // 'runtime_error' is not a member of 'std'
template <typename Traits> class unique_handle {
  using pointer = typename Traits::pointer;
  pointer m_value;
public:
  unique_handle(unique_handle const &) = delete;
  unique_handle &operator=(unique_handle const &) = delete;
  explicit unique_handle(pointer value = Traits::invalid()) noexcept
      : m_value{value} {}
  unique_handle(unique_handle &&other) noexcept : m_value{other.release()} {}
  unique_handle &operator=(unique_handle &&other) noexcept {
    if (this != &other) {
      reset(other.release());
    }
    return *this;
  }
  ~unique_handle() noexcept { Traits::close(m_value); }
  explicit operator bool() const noexcept {
    return m_value != Traits::invalid();
  }
  pointer get() const noexcept { return m_value; }
  pointer release() noexcept {
    auto value = m_value;
    m_value = Traits::invalid();
    return value;
  }
  bool reset(pointer value = Traits::invalid()) noexcept {
    if (m_value != value) {
      Traits::close(m_value);
      m_value = value;
    }
    return static_cast<bool>(*this);
  }
  void swap(unique_handle<Traits> &other) noexcept {
    std::swap(m_value, other.m_value);
  }
};
template <typename Traits>
void swap(unique_handle<Traits> &left, unique_handle<Traits> &right) noexcept {
  left.swap(right);
}
template <typename Traits>
bool operator==(unique_handle<Traits> const &left,
                unique_handle<Traits> const &right) noexcept {
  return left.get() == right.get();
}
template <typename Traits>
bool operator!=(unique_handle<Traits> const &left,
                unique_handle<Traits> const &right) noexcept {
  return left.get() != right.get();
}
struct null_handle_traits {
  using pointer = HANDLE;
  static pointer invalid() noexcept { return nullptr; }
  static void close(pointer value) noexcept { CloseHandle(value); }
};
struct invalid_handle_traits {
  using pointer = HANDLE;
  static pointer invalid() noexcept { return INVALID_HANDLE_VALUE; }
  static void close(pointer value) noexcept { CloseHandle(value); }
};
using null_handle = unique_handle<null_handle_traits>;
using invalid_handle = unique_handle<invalid_handle_traits>;
void function_that_throws() {
  throw std::runtime_error("an error has occurred");
}
void bad_handle_example() {
  bool condition1 = false;
  bool condition2 = true;
  HANDLE handle =
      CreateFile("sample.txt", GENERIC_READ, FILE_SHARE_READ, nullptr,
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
  if (handle == INVALID_HANDLE_VALUE)
    return;
  if (condition1) {
    CloseHandle(handle);
    return;
  }
  std::vector<char> buffer(1024);
  unsigned long bytesRead = 0;
  ReadFile(handle, buffer.data(), buffer.size(), &bytesRead, nullptr);
  if (condition2) {
    return;
  }
  function_that_throws();
  CloseHandle(handle);
}
void good_handle_example() {
  bool condition1 = false;
  bool condition2 = true;
  invalid_handle handle{CreateFile("sample.txt", GENERIC_READ, FILE_SHARE_READ,
                                   nullptr, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL, nullptr)};
  if (!handle)
    return;
  if (condition1)
    return;
  std::vector<char> buffer(1024);
  unsigned long bytesRead = 0;
  ReadFile(handle.get(), buffer.data(), buffer.size(), &bytesRead, nullptr);
  if (condition2)
    return;
  function_that_throws();
}
int main() {
  try {
    bad_handle_example();
  } catch (...) {
  }
  try {
    good_handle_example();
  } catch (...) {
  }
  return 0;
}
```

### 22. Literals of various temperature scales

```c++

#include <cmath>
#include <assert.h>
bool are_equal(double const d1, double const d2, double const epsilon = 0.001) {
  return std::fabs(d1 - d2) < epsilon;
}
namespace temperature {
enum class scale { celsius, fahrenheit, kelvin };
template <scale S> class quantity {
  const double amount;
public:
  constexpr explicit quantity(double const a) : amount(a) {}
  explicit operator double() const { return amount; }
};
template <scale S>
inline bool operator==(quantity<S> const &lhs, quantity<S> const &rhs) {
  return are_equal(static_cast<double>(lhs), static_cast<double>(rhs));
}
template <scale S>
inline bool operator!=(quantity<S> const &lhs, quantity<S> const &rhs) {
  return !(lhs == rhs);
}
template <scale S>
inline bool operator<(quantity<S> const &lhs, quantity<S> const &rhs) {
  return static_cast<double>(lhs) < static_cast<double>(rhs);
}
template <scale S>
inline bool operator>(quantity<S> const &lhs, quantity<S> const &rhs) {
  return rhs < lhs;
}
template <scale S>
inline bool operator<=(quantity<S> const &lhs, quantity<S> const &rhs) {
  return !(lhs > rhs);
}
template <scale S>
inline bool operator>=(quantity<S> const &lhs, quantity<S> const &rhs) {
  return !(lhs < rhs);
}
template <scale S>
constexpr quantity<S> operator+(quantity<S> const &q1, quantity<S> const &q2) {
  return quantity<S>(static_cast<double>(q1) + static_cast<double>(q2));
}
template <scale S>
constexpr quantity<S> operator-(quantity<S> const &q1, quantity<S> const &q2) {
  return quantity<S>(static_cast<double>(q1) - static_cast<double>(q2));
}
template <scale S, scale R> struct conversion_traits {
  static double convert(double const value) = delete;
};
template <> struct conversion_traits<scale::celsius, scale::kelvin> {
  static double convert(double const value) { return value + 273.15; }
};
template <> struct conversion_traits<scale::kelvin, scale::celsius> {
  static double convert(double const value) { return value - 273.15; }
};
template <> struct conversion_traits<scale::celsius, scale::fahrenheit> {
  static double convert(double const value) {
    return (value * 9) / 5 + 32;
    ;
  }
};
template <> struct conversion_traits<scale::fahrenheit, scale::celsius> {
  static double convert(double const value) { return (value - 32) * 5 / 9; }
};
template <> struct conversion_traits<scale::fahrenheit, scale::kelvin> {
  static double convert(double const value) { return (value + 459.67) * 5 / 9; }
};
template <> struct conversion_traits<scale::kelvin, scale::fahrenheit> {
  static double convert(double const value) { return (value * 9) / 5 - 459.67; }
};
template <scale R, scale S>
constexpr quantity<R> temperature_cast(quantity<S> const q) {
  return quantity<R>(conversion_traits<S, R>::convert(static_cast<double>(q)));
}
namespace temperature_scale_literals {
constexpr quantity<scale::celsius> operator"" _deg(long double const amount) {
  return quantity<scale::celsius>{static_cast<double>(amount)};
}
constexpr quantity<scale::fahrenheit> operator"" _f(long double const amount) {
  return quantity<scale::fahrenheit>{static_cast<double>(amount)};
}
constexpr quantity<scale::kelvin> operator"" _k(long double const amount) {
  return quantity<scale::kelvin>{static_cast<double>(amount)};
}
} // namespace temperature_scale_literals
} // namespace temperature
int main() {
  using namespace temperature;
  using namespace temperature_scale_literals;
  auto t1{36.5_deg};
  auto t2{79.0_f};
  auto t3{100.0_k};
  {
    auto tf = temperature_cast<scale::fahrenheit>(t1);
    auto tc = temperature_cast<scale::celsius>(tf);
    assert(t1 == tc);
  }
  {
    auto tk = temperature_cast<scale::kelvin>(t1);
    auto tc = temperature_cast<scale::celsius>(tk);
    assert(t1 == tc);
  }
  {
    auto tc = temperature_cast<scale::celsius>(t2);
    auto tf = temperature_cast<scale::fahrenheit>(tc);
    assert(t2 == tf);
  }
  {
    auto tk = temperature_cast<scale::kelvin>(t2);
    auto tf = temperature_cast<scale::fahrenheit>(tk);
    assert(t2 == tf);
  }
  {
    auto tc = temperature_cast<scale::celsius>(t3);
    auto tk = temperature_cast<scale::kelvin>(tc);
    assert(t3 == tk);
  }
  {
    auto tf = temperature_cast<scale::fahrenheit>(t3);
    auto tk = temperature_cast<scale::kelvin>(tf);
    assert(t3 == tk);
  }
}
```

## Strings and Regular Expressions

### 23. Binary to string conversion

```c++

#include <string>
#include <sstream>
#include <iomanip>
#include <vector>
#include <array>
#include <assert.h>
template <typename Iter>
std::string bytes_to_hexstr(Iter begin, Iter end,
                            bool const uppercase = false) {
  std::ostringstream oss;
  if (uppercase)
    oss.setf(std::ios_base::uppercase);
  for (; begin != end; ++begin)
    oss << std::hex << std::setw(2) << std::setfill('0')
        << static_cast<int>(*begin);
  return oss.str();
}
template <typename C>
std::string bytes_to_hexstr(C const &c, bool const uppercase = false) {
  return bytes_to_hexstr(std::cbegin(c), std::cend(c), uppercase);
}
int main() {
  std::vector<unsigned char> v{0xBA, 0xAD, 0xF0, 0x0D};
  std::array<unsigned char, 6> a{{1, 2, 3, 4, 5, 6}};
  unsigned char buf[5] = {0x11, 0x22, 0x33, 0x44, 0x55};
  assert(bytes_to_hexstr(v, true) == "BAADF00D");
  assert(bytes_to_hexstr(a, true) == "010203040506");
  assert(bytes_to_hexstr(buf, true) == "1122334455");
  assert(bytes_to_hexstr(v) == "baadf00d");
  assert(bytes_to_hexstr(a) == "010203040506");
  assert(bytes_to_hexstr(buf) == "1122334455");
}
```

### 24. String to binary conversion

```c++

#include <string>
#include <string_view>
#include <sstream>
#include <vector>
#include <array>
#include <assert.h>
unsigned char hexchar_to_int(char const ch) {
  if (ch >= '0' && ch <= '9')
    return ch - '0';
  if (ch >= 'A' && ch <= 'F')
    return ch - 'A' + 10;
  if (ch >= 'a' && ch <= 'f')
    return ch - 'a' + 10;
  throw std::invalid_argument("Invalid hexadecimal character");
}
std::vector<unsigned char> hexstr_to_bytes(std::string_view str) {
  std::vector<unsigned char> result;
  for (size_t i = 0; i < str.size(); i += 2) {
    result.push_back((hexchar_to_int(str[i]) << 4) |
                     hexchar_to_int(str[i + 1]));
  }
  return result;
}
int main() {
  std::vector<unsigned char> expected{0xBA, 0xAD, 0xF0, 0x0D, 0x42};
  assert(hexstr_to_bytes("BAADF00D42") == expected);
  assert(hexstr_to_bytes("BaaDf00d42") == expected);
}
```

### 25. Capitalizing an article title

```c++

#include <string>
#include <sstream>
#include <cctype>
#include <assert.h>
template <class Elem>
using tstring =
    std::basic_string<Elem, std::char_traits<Elem>, std::allocator<Elem>>;
template <class Elem>
using tstringstream =
    std::basic_stringstream<Elem, std::char_traits<Elem>, std::allocator<Elem>>;
template <class Elem> tstring<Elem> capitalize(tstring<Elem> const &text) {
  tstringstream<Elem> result;
  bool newWord = true;
  for (auto const ch : text) {
    newWord = newWord || std::ispunct(ch) || std::isspace(ch);
    if (std::isalpha(ch)) {
      if (newWord) {
        result << static_cast<Elem>(std::toupper(ch));
        newWord = false;
      } else
        result << static_cast<Elem>(std::tolower(ch));
    } else
      result << ch;
  }
  return result.str();
}
int main() {
  using namespace std::string_literals;
  std::string text = "THIS IS an ExamplE, should wORk!";
  std::string expected = "This Is An Example, Should Work!";
  assert(expected == capitalize(text));
  assert(L"The C++ Challenger"s == capitalize(L"the c++ challenger"s));
  assert(L"This Is An Example, Should Work!"s ==
         capitalize(L"THIS IS an ExamplE, should wORk!"s));
}
```

### 26. Joining strings together separated by a delimiter

```c++

#include <string>
#include <iterator>
#include <sstream>
#include <vector>
#include <array>
#include <list>
#include <assert.h>
template <typename Iter>
std::string join_strings(Iter begin, Iter end, char const *const separator) {
  std::ostringstream os;
  std::copy(begin, end - 1, std::ostream_iterator<std::string>(os, separator));
  os << *(end - 1);
  return os.str();
}
template <typename C>
std::string join_strings(C const &c, char const *const separator) {
  if (c.size() == 0)
    return std::string{};
  return join_strings(std::begin(c), std::end(c), separator);
}
int main() {
  using namespace std::string_literals;
  std::vector<std::string> v1{"this", "is", "an", "example"};
  std::vector<std::string> v2{"example"};
  std::vector<std::string> v3{};
  assert(join_strings(v1, " ") == "this is an example"s);
  assert(join_strings(v2, " ") == "example"s);
  assert(join_strings(v3, " ") == ""s);
  std::array<std::string, 4> a1{{"this", "is", "an", "example"}};
  std::array<std::string, 1> a2{{"example"}};
  std::array<std::string, 0> a3{};
  assert(join_strings(a1, " ") == "this is an example"s);
  assert(join_strings(a2, " ") == "example"s);
  assert(join_strings(a3, " ") == ""s);
}
```

### 27. Splitting a string into tokens with a list of possible delimiters

```c++

#include <string>
#include <sstream>
#include <vector>
#include <assert.h>
template <class Elem>
using tstring =
    std::basic_string<Elem, std::char_traits<Elem>, std::allocator<Elem>>;
template <class Elem>
using tstringstream =
    std::basic_stringstream<Elem, std::char_traits<Elem>, std::allocator<Elem>>;
template <typename Elem>
inline std::vector<tstring<Elem>> split(tstring<Elem> text,
                                        Elem const delimiter) {
  auto sstr = tstringstream<Elem>{text};
  auto tokens = std::vector<tstring<Elem>>{};
  auto token = tstring<Elem>{};
  while (std::getline(sstr, token, delimiter)) {
    if (!token.empty())
      tokens.push_back(token);
  }
  return tokens;
}
template <typename Elem>
inline std::vector<tstring<Elem>> split(tstring<Elem> text,
                                        tstring<Elem> const &delimiters) {
  auto tokens = std::vector<tstring<Elem>>{};
  size_t pos, prev_pos = 0;
  while ((pos = text.find_first_of(delimiters, prev_pos)) !=
         std::string::npos) {
    if (pos > prev_pos)
      tokens.push_back(text.substr(prev_pos, pos - prev_pos));
    prev_pos = pos + 1;
  }
  if (prev_pos < text.length())
    tokens.push_back(text.substr(prev_pos, std::string::npos));
  return tokens;
}
int main() {
  using namespace std::string_literals;
  std::vector<std::string> expected{"this", "is", "a", "sample"};
  assert(expected == split("this is a sample"s, ' '));
  assert(expected == split("this,is a.sample!!"s, ",.! "s));
}
```

### 28. Longest palindromic substring

```c++

#include <string>
#include <string_view>
#include <vector>
#include <assert.h>
std::string longest_palindrome(std::string_view str) {
  size_t const len = str.size();
  size_t longestBegin = 0;
  size_t maxLen = 1;
  std::vector<bool> table(len * len, false);
  for (size_t i = 0; i < len; i++) {
    table[i * len + i] = true;
  }
  for (size_t i = 0; i < len - 1; i++) {
    if (str[i] == str[i + 1]) {
      table[i * len + i + 1] = true;
      if (maxLen < 2) {
        longestBegin = i;
        maxLen = 2;
      }
    }
  }
  for (size_t k = 3; k <= len; k++) {
    for (size_t i = 0; i < len - k + 1; i++) {
      size_t j = i + k - 1;
      if (str[i] == str[j] && table[(i + 1) * len + j - 1]) {
        table[i * len + j] = true;
        if (maxLen < k) {
          longestBegin = i;
          maxLen = k;
        }
      }
    }
  }
  return std::string(str.substr(longestBegin, maxLen));
}
int main() {
  using namespace std::string_literals;
  assert(longest_palindrome("sahararahnide") == "hararah");
  assert(longest_palindrome("level") == "level");
  assert(longest_palindrome("s") == "s");
  assert(longest_palindrome("aabbcc") == "aa");
  assert(longest_palindrome("abab") == "aba");
}
```

### 29. License plate validation

```c++

#include <string>
#include <string_view>
#include <regex>
#include <assert.h>
bool validate_license_plate_format(std::string_view str) {
  std::regex rx(R"([A-Z]{3}-[A-Z]{2} \d{3,4})");
  return std::regex_match(str.data(), rx);
}
std::vector<std::string> extract_license_plate_numbers(std::string const &str) {
  std::regex rx(R"(([A-Z]{3}-[A-Z]{2} \d{3,4})*)");
  std::smatch match;
  std::vector<std::string> results;
  for (auto i = std::sregex_iterator(std::cbegin(str), std::cend(str), rx);
       i != std::sregex_iterator(); ++i) {
    if ((*i)[1].matched)
      results.push_back(i->str());
  }
  return results;
}
int main() {
  assert(validate_license_plate_format("ABC-DE 123"));
  assert(validate_license_plate_format("ABC-DE 1234"));
  assert(!validate_license_plate_format("ABC-DE 12345"));
  assert(!validate_license_plate_format("abc-de 1234"));
  std::vector<std::string> expected{"AAA-AA 123", "ABC-DE 1234", "XYZ-WW 0001"};
  std::string text("AAA-AA 123qwe-ty 1234  ABC-DE 123456..XYZ-WW 0001");
  assert(expected == extract_license_plate_numbers(text));
}
```

### 30. Extracting URL parts

```c++

#include <string>
#include <string_view>
#include <regex>
#include <assert.h>
#ifdef USE_BOOST_OPTIONAL
#include <boost/optional.hpp>
using boost::optional;
#else
#include <optional>
using std::optional;
#endif
struct uri_parts {
  std::string protocol;
  std::string domain;
  optional<int> port;
  optional<std::string> path;
  optional<std::string> query;
  optional<std::string> fragment;
};
optional<uri_parts> parse_uri(std::string uri) {
  std::regex rx(
      R"(^(\w+):\/\/([\w.-]+)(:(\d+))?([\w\/\.]+)?(\?([\w=&]*)(#?(\w+))?)?$)");
  auto matches = std::smatch{};
  if (std::regex_match(uri, matches, rx)) {
    if (matches[1].matched && matches[2].matched) {
      uri_parts parts;
      parts.protocol = matches[1].str();
      parts.domain = matches[2].str();
      if (matches[4].matched)
        parts.port = std::stoi(matches[4]);
      if (matches[5].matched)
        parts.path = matches[5];
      if (matches[7].matched)
        parts.query = matches[7];
      if (matches[9].matched)
        parts.fragment = matches[9];
      return parts;
    }
  }
  return {};
}
int main() {
  auto p1 = parse_uri("https://packt.com");
  assert(p1);
  assert(p1->protocol == "https");
  assert(p1->domain == "packt.com");
  assert(!p1->port);
  assert(!p1->path);
  assert(!p1->query);
  assert(!p1->fragment);
  auto p2 = parse_uri("https://bbc.com:80/en/index.html?lite=true#ui");
  assert(p2);
  assert(p2->protocol == "https");
  assert(p2->domain == "bbc.com");
  assert(p2->port == 80);
  assert(p2->path.value() == "/en/index.html");
  assert(p2->query.value() == "lite=true");
  assert(p2->fragment.value() == "ui");
}
```

### 31. Transforming dates in strings

```c++

#include <string>
#include <string_view>
#include <regex>
#include <assert.h>
std::string transform_date(std::string_view text) {
  auto rx = std::regex{R"((\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4}))"};
  return std::regex_replace(text.data(), rx, R"($5-$3-$1)");
}
int main() {
  using namespace std::string_literals;
  assert(transform_date("today is 01.12.2017!"s) == "today is 2017-12-01!"s);
}
```

## Streams and Filesystems

### 32. Pascal's triangle

```c++

#include <string>
#include <iostream>
#include <cmath>
unsigned int number_of_digits(unsigned int const i) {
  return i > 0 ? (int)log10((double)i) + 1 : 1;
}
void print_pascal_triangle(int const n) {
  for (int i = 0; i < n; i++) {
    auto x = 1;
    std::cout << std::string((n - i - 1) * (n / 2), ' ');
    for (int j = 0; j <= i; j++) {
      auto y = x;
      x = x * (i - j) / (j + 1);
      auto maxlen = number_of_digits(x) - 1;
      std::cout << y << std::string(n - 1 - maxlen - n % 2, ' ');
    }
    std::cout << std::endl;
  }
}
int main() {
  int n = 0;
  std::cout << "Levels (up to 10): ";
  std::cin >> n;
  if (n > 10)
    std::cout << "Value too large" << std::endl;
  else
    print_pascal_triangle(n);
}
```

### 33. Tabular printing of a list of processes

```c++

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <algorithm>
enum class procstatus { suspended, running };
std::string status_to_string(procstatus const status) {
  if (status == procstatus::suspended)
    return "suspended";
  else
    return "running";
}
enum class platforms { p32bit, p64bit };
std::string platform_to_string(platforms const platform) {
  if (platform == platforms::p32bit)
    return "32-bit";
  else
    return "64-bit";
}
struct procinfo {
  int id;
  std::string name;
  procstatus status;
  std::string account;
  size_t memory;
  platforms platform;
};
void print_processes(std::vector<procinfo> processes) {
  std::sort(
      std::begin(processes), std::end(processes),
      [](procinfo const &p1, procinfo const &p2) { return p1.name < p2.name; });
  for (auto const &pi : processes) {
    std::cout << std::left << std::setw(25) << std::setfill(' ') << pi.name;
    std::cout << std::left << std::setw(8) << std::setfill(' ') << pi.id;
    std::cout << std::left << std::setw(12) << std::setfill(' ')
              << status_to_string(pi.status);
    std::cout << std::left << std::setw(15) << std::setfill(' ') << pi.account;
    std::cout << std::right << std::setw(10) << std::setfill(' ')
              << (int)(pi.memory / 1024);
    std::cout << std::left << ' ' << platform_to_string(pi.platform);
    std::cout << std::endl;
  }
}
int main() {
  using namespace std::string_literals;
  std::vector<procinfo> processes{
      {512, "cmd.exe"s, procstatus::running, "SYSTEM"s, 148293,
       platforms::p64bit},
      {1044, "chrome.exe"s, procstatus::running, "marius.bancila"s, 25180454,
       platforms::p32bit},
      {7108, "explorer.exe"s, procstatus::running, "marius.bancila"s, 2952943,
       platforms::p64bit},
      {10100, "chrome.exe"s, procstatus::running, "marius.bancila"s, 227756123,
       platforms::p32bit},
      {22456, "skype.exe"s, procstatus::suspended, "marius.bancila"s, 16870123,
       platforms::p64bit},
  };
  print_processes(processes);
}
```

### 34. Removing empty lines from a text file

```c++

// -lstdc++fs
#include <fstream>
#include <string> 
#ifdef USE_BOOST_FILESYSTEM
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#include <filesystem>
#ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#else
namespace fs = std::filesystem;
#endif
#endif
void remove_empty_lines(fs::path filepath) {
  std::ifstream filein(filepath.native(), std::ios::in);
  if (!filein.is_open())
    throw std::runtime_error("cannot open input file");
  auto temppath = fs::temp_directory_path() / "temp.txt";
  std::ofstream fileout(temppath.native(), std::ios::out | std::ios::trunc);
  if (!fileout.is_open())
    throw std::runtime_error("cannot create temporary file");
  std::string line;
  while (std::getline(filein, line)) {
    if (line.length() > 0 && line.find_first_not_of(' ') != line.npos) {
      fileout << line << '\n';
    }
  }
  filein.close();
  fileout.close();
  fs::remove(filepath);
  fs::rename(temppath, filepath);
}
int main() { remove_empty_lines("sample34.txt"); }
```

### 35. Computing the size of a directory

```c++

#include <iostream>
#include <numeric>
#include <string>
#ifdef USE_BOOST_FILESYSTEM
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#include <filesystem>
#ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#else
namespace fs = std::filesystem;
#endif
#endif
std::uintmax_t get_directory_size(fs::path const &dir,
                                  bool const follow_symlinks = false) {
#ifdef USE_BOOST_FILESYSTEM
  auto iterator = fs::recursive_directory_iterator(
      dir,
      follow_symlinks ? fs::symlink_option::recurse : fs::symlink_option::none);
#else
  auto iterator = fs::recursive_directory_iterator(
      dir, follow_symlinks ? fs::directory_options::follow_directory_symlink
                           : fs::directory_options::none);
#endif
  return std::accumulate(
      fs::begin(iterator), fs::end(iterator), 0ull,
      [](std::uintmax_t const total, fs::directory_entry const &entry) {
        return total +
               (fs::is_regular_file(entry) ? fs::file_size(entry.path()) : 0);
      });
}
int main() {
  std::string path;
  std::cout << "Path: ";
  std::cin >> path;
  std::cout << "Size: " << get_directory_size(path) << std::endl;
}
```

### 36. Deleting files older than a given date

```c++

#include <iostream>
#include <chrono>
#ifdef USE_BOOST_FILESYSTEM
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#include <filesystem>
#ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#else
namespace fs = std::filesystem;
#endif
#endif
namespace ch = std::chrono;
template <typename Duration>
bool is_older_than(fs::path const &path, Duration const duration) {
  auto lastwrite = fs::last_write_time(path);
#ifdef USE_BOOST_FILESYSTEM
  auto ftimeduration =
      ch::system_clock::from_time_t(lastwrite).time_since_epoch();
#else
  auto ftimeduration = lastwrite.time_since_epoch();
#endif
  auto nowduration = (ch::system_clock::now() - duration).time_since_epoch();
  return ch::duration_cast<Duration>(nowduration - ftimeduration).count() > 0;
}
template <typename Duration>
void remove_files_older_than(fs::path const &path, Duration const duration) {
  try {
    if (fs::exists(path)) {
      if (is_older_than(path, duration)) {
        fs::remove(path);
      } else if (fs::is_directory(path)) {
        for (auto const &entry : fs::directory_iterator(path)) {
          remove_files_older_than(entry.path(), duration);
        }
      }
    }
  } catch (std::exception const &ex) {
    std::cerr << ex.what() << std::endl;
  }
}
int main() {
  using namespace std::chrono_literals;
#ifdef _WIN32
  auto path = R"(..\Test\)";
#else
  auto path = R"(../Test/)";
#endif
  remove_files_older_than(path, 1h + 20min);
}
```

### 37. Finding files in a directory that match a regular expression

```c++

#include <iostream>
#include <regex>
#include <vector>
#include <string>
#include <string_view>
#include <functional>
#ifdef USE_BOOST_FILESYSTEM
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#include <filesystem>
#ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#else
namespace fs = std::filesystem;
#endif
#endif
std::vector<fs::directory_entry> find_files(fs::path const &path,
                                            std::string_view regex) {
  std::vector<fs::directory_entry> result;
  std::regex rx(regex.data());
  std::copy_if(fs::recursive_directory_iterator(path),
               fs::recursive_directory_iterator(), std::back_inserter(result),
               [&rx](fs::directory_entry const &entry) {
                 return fs::is_regular_file(entry.path()) &&
                        std::regex_match(entry.path().filename().string(), rx);
               });
  return result;
}
int main() {
  auto dir = fs::temp_directory_path();
  auto pattern = R"(wct[0-9a-zA-Z]{3}\.tmp)";
  auto result = find_files(dir, pattern);
  for (auto const &entry : result) {
    std::cout << entry.path().string() << std::endl;
  }
}
```

### 38. Temporary log files

```c++

#include <iostream>
#include <fstream>
#include "uuid.h"
#ifdef USE_BOOST_FILESYSTEM
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#include <filesystem>
#ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#else
namespace fs = std::filesystem;
#endif
#endif
class logger {
  fs::path logpath;
  std::ofstream logfile;
public:
  logger() {
    auto name = uuids::to_string(uuids::uuid_random_generator{}());
    logpath = fs::temp_directory_path() / (name + ".tmp");
    logfile.open(logpath.c_str(), std::ios::out | std::ios::trunc);
  }
  ~logger() noexcept {
    try {
      if (logfile.is_open())
        logfile.close();
      if (!logpath.empty())
        fs::remove(logpath);
    } catch (...) {
    }
  }
  void persist(fs::path const &path) {
    logfile.close();
    fs::rename(logpath, path);
    logpath.clear();
  }
  logger &operator<<(std::string_view message) {
    logfile << message.data() << '\n';
    return *this;
  }
};
int main() {
  logger log;
  try {
    log << "this is a line"
        << "and this is another one";
    throw std::runtime_error("error");
  } catch (...) {
    log.persist(R"(lastlog.txt)");
  }
}
```

## Date and Time

### 39. Measuring function execution time

```c++

#include <iostream>
#include <chrono>
#include <thread>
#include <functional>
template <typename Time = std::chrono::microseconds,
          typename Clock = std::chrono::high_resolution_clock>
struct perf_timer {
  template <typename F, typename... Args>
  static Time duration(F &&f, Args... args) {
    auto start = Clock::now();
    std::invoke(std::forward<F>(f), std::forward<Args>(args)...);
    auto end = Clock::now();
    return std::chrono::duration_cast<Time>(end - start);
  }
};
using namespace std::chrono_literals;
void f() {
  // simulate work
  std::this_thread::sleep_for(2s);
}
void g(int const a, int const b) {
  // simulate work
  std::this_thread::sleep_for(1s);
}
int main() {
  auto t1 = perf_timer<std::chrono::microseconds>::duration(f);
  auto t2 = perf_timer<std::chrono::milliseconds>::duration(g, 1, 2);
  auto total = std::chrono::duration<double, std::nano>(t1 + t2).count();
  std::cout << total << std::endl;
}
```

### 40. Number of days between two dates

```c++

// -I "C:\Codes\Codes\C++\Module 3_TheModernCppChallenge_Code\libs\date\include\date"
#include <iostream>
#include "date.h"
inline int number_of_days(int const y1, unsigned int const m1,
                          unsigned int const d1, int const y2,
                          unsigned int const m2, unsigned int const d2) {
  using namespace date;
  return (sys_days{year{y1} / month{m1} / day{d1}} -
          sys_days{year{y2} / month{m2} / day{d2}})
      .count();
}
inline int number_of_days(date::sys_days const &first,
                          date::sys_days const &last) {
  return (last - first).count();
}
int main() {
  unsigned int y1 = 0, m1 = 0, d1 = 0;
  std::cout << "First date" << std::endl;
  std::cout << "Year:";
  std::cin >> y1;
  std::cout << "Month:";
  std::cin >> m1;
  std::cout << "Date:";
  std::cin >> d1;
  std::cout << "Second date" << std::endl;
  unsigned int y2 = 0, m2 = 0, d2 = 0;
  std::cout << "Year:";
  std::cin >> y2;
  std::cout << "Month:";
  std::cin >> m2;
  std::cout << "Date:";
  std::cin >> d2;
  std::cout << "Days between:" << number_of_days(y1, m1, d1, y2, m2, d2)
            << std::endl;
  using namespace date::literals;
  std::cout << "Days between:"
            << number_of_days(2018_y / jun / 1, 15_d / sep / 2018) << std::endl;
}
```

### 41. Day of the week

```c++

// -I "C:\Codes\Codes\C++\Module 3_TheModernCppChallenge_Code\libs\date\include\date"
#include <iostream>
#include "date.h"
#include "iso_week.h"
unsigned int week_day(int const y, unsigned int const m, unsigned int const d) {
  using namespace date;
  if (m < 1 || m > 12 || d < 1 || d > 31)
    return 0;
  auto const dt = date::year_month_day{year{y}, month{m}, day{d}};
  auto const tiso = iso_week::year_weeknum_weekday{dt};
  return (unsigned int)tiso.weekday();
}
int main() {
  int y = 0;
  unsigned int m = 0, d = 0;
  std::cout << "Year:";
  std::cin >> y;
  std::cout << "Month:";
  std::cin >> m;
  std::cout << "Day:";
  std::cin >> d;
  std::cout << "Day of week:" << week_day(y, m, d) << std::endl;
}
```

### 42. Day and week of the year

```c++

// -I "C:\Codes\Codes\C++\Module 3_TheModernCppChallenge_Code\libs\date\include\date"
#include <iostream>
#include "date.h"
#include "iso_week.h"
unsigned int calendar_week(int const y, unsigned int const m,
                           unsigned int const d) {
  using namespace date;
  if (m < 1 || m > 12 || d < 1 || d > 31)
    return 0;
  auto const dt = date::year_month_day{year{y}, month{m}, day{d}};
  auto const tiso = iso_week::year_weeknum_weekday{dt};
  return (unsigned int)tiso.weeknum();
}
int day_of_year(int const y, unsigned int const m, unsigned int const d) {
  using namespace date;
  if (m < 1 || m > 12 || d < 1 || d > 31)
    return 0;
  return (sys_days{year{y} / month{m} / day{d}} - sys_days{year{y} / jan / 0})
      .count();
}
int main() {
  int y = 0;
  unsigned int m = 0, d = 0;
  std::cout << "Year:";
  std::cin >> y;
  std::cout << "Month:";
  std::cin >> m;
  std::cout << "Day:";
  std::cin >> d;
  std::cout << "Calendar week:" << calendar_week(y, m, d) << std::endl;
  std::cout << "Day of year:" << day_of_year(y, m, d) << std::endl;
}
```

### 43. Meeting time for multiple time zones

```c++

// -I "C:\Codes\Codes\C++\Module 3_TheModernCppChallenge_Code\libs\date\include\date"
#include <iostream>
#include <string>
#include <vector>
#include <string_view>
#include <iomanip>
#include "date.h"
#include "tz.h"
namespace ch = std::chrono;
struct user {
  std::string Name;
  date::time_zone const *Zone;
  user(std::string_view name, std::string_view zone)
      : Name{name.data()}, Zone(date::locate_zone(zone.data())) {}
};
template <class Duration, class TimeZonePtr>
void print_meeting_times(date::zoned_time<Duration, TimeZonePtr> const &time,
                         std::vector<user> const &users) {
  std::cout << std::left << std::setw(15) << std::setfill(' ')
            << "Local time: " << time << std::endl;
  for (auto const &user : users) {
    std::cout << std::left << std::setw(15) << std::setfill(' ') << user.Name
              << date::zoned_time<Duration, TimeZonePtr>(user.Zone, time)
              << std::endl;
  }
}
int main() {
  std::vector<user> users{user{"Ildiko", "Europe/Budapest"},
                          user{"Jens", "Europe/Berlin"},
                          user{"Jane", "America/New_York"}};
  unsigned int h, m;
  std::cout << "Hour:";
  std::cin >> h;
  std::cout << "Minutes:";
  std::cin >> m;
  date::year_month_day today = date::floor<date::days>(ch::system_clock::now());
  auto localtime = date::zoned_time<std::chrono::minutes>(
      date::current_zone(),
      static_cast<date::local_days>(today) + ch::hours{h} + ch::minutes{m});
  print_meeting_times(localtime, users);
}
```

### 44. Monthly calendar

```c++

// -I "C:\Codes\Codes\C++\Module 3_TheModernCppChallenge_Code\libs\date\include\date"
#include <iostream>
#include <iomanip>
#include "date.h"
#include "iso_week.h"
unsigned int week_day(int const y, unsigned int const m, unsigned int const d) {
  using namespace date;
  if (m < 1 || m > 12 || d < 1 || d > 31)
    return 0;
  auto const dt = date::year_month_day{year{y}, month{m}, day{d}};
  auto const tiso = iso_week::year_weeknum_weekday{dt};
  return (unsigned int)tiso.weekday();
}
void print_month_calendar(int const y, unsigned int m) {
  using namespace date;
  std::cout << "Mon Tue Wed Thu Fri Sat Sun" << std::endl;
  auto first_day_weekday = week_day(y, m, 1);
  auto last_day =
      (unsigned int)year_month_day_last(year{y}, month_day_last{month{m}})
          .day();
  unsigned int index = 1;
  for (unsigned int day = 1; day < first_day_weekday; ++day, ++index) {
    std::cout << "    ";
  }
  for (unsigned int day = 1; day <= last_day; ++day) {
    std::cout << std::right << std::setfill(' ') << std::setw(3) << day << ' ';
    if (index++ % 7 == 0)
      std::cout << std::endl;
  }
  std::cout << std::endl;
}
int main() {
  unsigned int y = 0, m = 0;
  std::cout << "Year:";
  std::cin >> y;
  std::cout << "Month:";
  std::cin >> m;
  print_month_calendar(y, m);
}
```

## Algorithms and Data Structures

### 45. Priority queue

```c++

#include <iostream>
#include <vector>
#include <algorithm>
#include <assert.h>
template <class T,
          class Compare = std::less<typename std::vector<T>::value_type>>
class priority_queue {
  typedef typename std::vector<T>::value_type value_type;
  typedef typename std::vector<T>::size_type size_type;
  typedef typename std::vector<T>::reference reference;
  typedef typename std::vector<T>::const_reference const_reference;
public:
  bool empty() const noexcept { return data.empty(); }
  size_type size() const noexcept { return data.size(); }
  void push(value_type const &value) {
    data.push_back(value);
    std::push_heap(std::begin(data), std::end(data), comparer);
  }
  void pop() {
    std::pop_heap(std::begin(data), std::end(data), comparer);
    data.pop_back();
  }
  const_reference top() const { return data.front(); }
  void swap(priority_queue &other) noexcept {
    swap(data, other.data);
    swap(comparer, other.comparer);
  }
private:
  std::vector<T> data;
  Compare comparer;
};
template <class T, class Compare>
void swap(priority_queue<T, Compare> &lhs,
          priority_queue<T, Compare> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
  lhs.swap(rhs);
}
int main() {
  priority_queue<int> q;
  for (int i : {1, 5, 3, 1, 13, 21, 8}) {
    q.push(i);
  }
  assert(!q.empty());
  assert(q.size() == 7);
  while (!q.empty()) {
    std::cout << q.top() << ' ';
    q.pop();
  }
}
```

### 46. Circular buffer

```c++

#include <iostream>
#include <vector>
#include <assert.h>
template <class T>
class circular_buffer;
template <class T>
class circular_buffer_iterator
{
   typedef circular_buffer_iterator          self_type;
   typedef T                                 value_type;
   typedef T&                                reference;
   typedef T const&                          const_reference;
   typedef T*                                pointer;
   typedef std::random_access_iterator_tag   iterator_category;
   typedef ptrdiff_t                         difference_type;
public:
   circular_buffer_iterator(circular_buffer<T> const & buf, size_t const pos, bool const last) :
      buffer_(buf), index_(pos), last_(last)
   {}
   self_type & operator++ ()
   {
      if (last_)
         throw std::out_of_range("Iterator cannot be incremented past the end of range.");
      index_ = (index_ + 1) % buffer_.data_.size();
      last_ = index_ == buffer_.next_pos();
      return *this;
   }
   self_type operator++ (int)
   {
      self_type tmp = *this;
      ++*this;
      return tmp;
   }
   bool operator== (self_type const & other) const
   {
      assert(compatible(other));
      return index_ == other.index_ && last_ == other.last_;
   }
   bool operator!= (self_type const & other) const
   {
      return !(*this == other);
   }
   const_reference operator* () const
   {
      return buffer_.data_[index_];
   }
   const_reference operator-> () const
   {
      return buffer_.data_[index_];
   }
private:
   bool compatible(self_type const & other) const
   {
      return &buffer_ == &other.buffer_;
   }
   circular_buffer<T> const & buffer_;
   size_t index_;
   bool last_;
};
template <class T>
class circular_buffer
{
   typedef circular_buffer_iterator<T> const_iterator;
   circular_buffer() = delete;
public:
   explicit circular_buffer(size_t const size) :data_(size)
   {}
   bool clear() noexcept { head_ = -1; size_ = 0; }
   bool empty() const noexcept { return size_ == 0; }
   bool full() const noexcept { return size_ == data_.size(); }
   size_t capacity() const noexcept { return data_.size(); }
   size_t size() const noexcept { return size_; }
   void push(T const item)
   {
      head_ = next_pos();
      data_[head_] = item;
      if (size_ < data_.size()) size_++;
   }
   T pop()
   {
      if (empty()) throw std::runtime_error("empty buffer");
      auto pos = first_pos();
      size_--;
      return data_[pos];
   }
   const_iterator begin() const
   {
      return const_iterator(*this, first_pos(), empty());
   }
   const_iterator end() const
   {
      return const_iterator(*this, next_pos(), true);
   }
private:
   std::vector<T> data_;
   size_t head_ = -1;
   size_t size_ = 0;
   size_t next_pos() const noexcept { return size_ == 0 ? 0 : (head_ + 1) % data_.size(); }
   size_t first_pos() const noexcept { return size_ == 0 ? 0 : (head_ + data_.size() - size_ + 1) % data_.size(); }
   friend class circular_buffer_iterator<T>;
};
template <typename T>
void print(circular_buffer<T> & buf)
{
   for (auto & e : buf)
   {
      std::cout << e << ' ';
   }
   std::cout << std::endl;
}
int main()
{
   circular_buffer<int> cbuf(5);
   assert(cbuf.empty());
   assert(!cbuf.full());
   assert(cbuf.size() == 0);
   print(cbuf);
   cbuf.push(1);
   cbuf.push(2);
   cbuf.push(3);
   assert(!cbuf.empty());
   assert(!cbuf.full());
   assert(cbuf.size() == 3);
   print(cbuf);
   auto item = cbuf.pop();
   assert(item == 1);
   assert(!cbuf.empty());
   assert(!cbuf.full());
   assert(cbuf.size() == 2);
   cbuf.push(4);
   cbuf.push(5);
   cbuf.push(6);
   assert(!cbuf.empty());
   assert(cbuf.full());
   assert(cbuf.size() == 5);
   print(cbuf);
   cbuf.push(7);
   cbuf.push(8);
   assert(!cbuf.empty());
   assert(cbuf.full());
   assert(cbuf.size() == 5);
   print(cbuf);
   item = cbuf.pop();
   assert(item == 4);
   item = cbuf.pop();
   assert(item == 5);
   item = cbuf.pop();
   assert(item == 6);
   assert(!cbuf.empty());
   assert(!cbuf.full());
   assert(cbuf.size() == 2);
   print(cbuf);
   item = cbuf.pop();
   assert(item == 7);
   item = cbuf.pop();
   assert(item == 8);
   assert(cbuf.empty());
   assert(!cbuf.full());
   assert(cbuf.size() == 0);
   print(cbuf);
   cbuf.push(9);
   assert(!cbuf.empty());
   assert(!cbuf.full());
   assert(cbuf.size() == 1);
   print(cbuf);
}
```

### 47. Double buffer

```c++

#include <vector>
#include <iostream>
#include <algorithm>
#include <thread>
#include <chrono>
#include <mutex>
#include <iterator>
template <typename T> class double_buffer {
  typedef T value_type;
  typedef T &reference;
  typedef T const &const_reference;
  typedef T *pointer;
public:
  explicit double_buffer(size_t const size) : rdbuf(size), wrbuf(size) {}
  size_t size() const noexcept { return rdbuf.size(); }
  void write(T const *const ptr, size_t const size) {
    std::unique_lock<std::mutex> lock(mt);
    auto length = std::min(size, wrbuf.size());
    std::copy(ptr, ptr + length, std::begin(wrbuf));
    wrbuf.swap(rdbuf);
  }
  template <class Output> void read(Output it) const {
    std::unique_lock<std::mutex> lock(mt);
    std::copy(std::cbegin(rdbuf), std::cend(rdbuf), it);
  }
  pointer data() const {
    std::unique_lock<std::mutex> lock(mt);
    return rdbuf.data();
  }
  reference operator[](size_t const pos) {
    std::unique_lock<std::mutex> lock(mt);
    return rdbuf[pos];
  }
  const_reference operator[](size_t const pos) const {
    std::unique_lock<std::mutex> lock(mt);
    return rdbuf[pos];
  }
  void swap(double_buffer other) {
    std::swap(rdbuf, other.rdbuf);
    std::swap(wrbuf, other.wrbuf);
  }
private:
  std::vector<T> rdbuf;
  std::vector<T> wrbuf;
  mutable std::mutex mt;
};
template <typename T> void print_buffer(double_buffer<T> const &buf) {
  buf.read(std::ostream_iterator<T>(std::cout, " "));
  std::cout << std::endl;
}
int main() {
  double_buffer<int> buf(10);
  std::thread t([&buf]() {
    for (int i = 1; i < 1000; i += 10) {
      int data[] = {i,     i + 1, i + 2, i + 3, i + 4,
                    i + 5, i + 6, i + 7, i + 8, i + 9};
      buf.write(data, 10);
      using namespace std::chrono_literals;
      std::this_thread::sleep_for(100ms);
    }
  });
  auto start = std::chrono::system_clock::now();
  do {
    print_buffer(buf);
    using namespace std::chrono_literals;
    std::this_thread::sleep_for(150ms);
  } while (std::chrono::duration_cast<std::chrono::seconds>(
               std::chrono::system_clock::now() - start)
               .count() < 12);
  t.join();
}
```

### 48. The most frequent element in a range

```c++

#include <iostream>
#include <map>
#include <vector>
#include <algorithm>
template <typename T>
std::vector<std::pair<T, size_t>>
find_most_frequent(std::vector<T> const &range) {
  std::map<T, size_t> counts;
  for (auto const &e : range)
    counts[e]++;
  auto maxelem = std::max_element(
      std::cbegin(counts), std::cend(counts),
      [](auto const &e1, auto const &e2) { return e1.second < e2.second; });
  std::vector<std::pair<T, size_t>> result;
  std::copy_if(
      std::begin(counts), std::end(counts), std::back_inserter(result),
      [maxelem](auto const &kvp) { return kvp.second == maxelem->second; });
  return result;
}
int main() {
  auto range = std::vector<int>{1, 1, 3, 5, 8, 13, 3, 5, 8, 8, 5};
  auto result = find_most_frequent(range);
  for (auto const &e : result) {
    std::cout << e.first << " : " << e.second << std::endl;
  }
}
```

### 49. Text histogram

```c++

#include <iostream>
#include <map>
#include <algorithm>
#include <numeric>
#include <iomanip>
#include <string>
#include <string_view>
std::map<char, double> analyze_text(std::string_view text) {
  std::map<char, double> frequencies;
  for (char ch = 'a'; ch <= 'z'; ch++)
    frequencies[ch] = 0;
  for (auto ch : text) {
    if (isalpha(ch))
      frequencies[tolower(ch)]++;
  }
  auto total = std::accumulate(std::cbegin(frequencies), std::cend(frequencies),
                               0ull, [](auto const sum, auto const &kvp) {
                                 return sum + static_cast<unsigned long long>(
                                                  kvp.second);
                               });
  std::for_each(
      std::begin(frequencies), std::end(frequencies),
      [total](auto &kvp) { kvp.second = (100.0 * kvp.second) / total; });
  return frequencies;
}
int main() {
  auto result = analyze_text(
      R"(Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.)");
  for (auto const &kvp : result) {
    std::cout << kvp.first << " : " << std::fixed << std::setw(5)
              << std::setfill(' ') << std::setprecision(2) << kvp.second
              << std::endl;
  }
}
```

### 50. Filtering a list of phone numbers

```c++

#include <string>
#include <string_view>
#include <vector>
#include <iostream>
#include <algorithm>
bool starts_with(std::string_view str, std::string_view prefix) {
  return str.find(prefix) == 0;
}
template <typename InputIt>
std::vector<std::string> filter_numbers(InputIt begin, InputIt end,
                                        std::string const &countryCode) {
  std::vector<std::string> result;
  std::copy_if(begin, end, std::back_inserter(result),
               [countryCode](auto const &number) {
                 return starts_with(number, countryCode) ||
                        starts_with(number, "+" + countryCode);
               });
  return result;
}
std::vector<std::string> filter_numbers(std::vector<std::string> const &numbers,
                                        std::string const &countryCode) {
  return filter_numbers(std::cbegin(numbers), std::cend(numbers), countryCode);
}
int main() {
  std::vector<std::string> numbers{"+40744909080", "44 7520 112233",
                                   "+44 7555 123456", "40 7200 123456",
                                   "7555 123456"};
  auto result = filter_numbers(numbers, "44");
  for (auto const &number : result) {
    std::cout << number << std::endl;
  }
}
```

### 51. Transforming a list of phone numbers

```c++

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
bool starts_with(std::string_view str, std::string_view prefix) {
  return str.find(prefix) == 0;
}
void normalize_phone_numbers(std::vector<std::string> &numbers,
                             std::string const &countryCode) {
  std::transform(
      std::cbegin(numbers), std::cend(numbers), std::begin(numbers),
      [countryCode](std::string const &number) {
        std::string result;
        if (number.size() > 0) {
          if (number[0] == '0')
            result = "+" + countryCode + number.substr(1);
          else if (starts_with(number, countryCode))
            result = "+" + number;
          else if (starts_with(number, "+" + countryCode))
            result = number;
          else
            result = "+" + countryCode + number;
        }
        result.erase(std::remove_if(std::begin(result), std::end(result),
                                    [](const char ch) { return isspace(ch); }),
                     std::end(result));
        return result;
      });
}
int main() {
  std::vector<std::string> numbers{"07555 123456", "07555123456",
                                   "+44 7555 123456", "44 7555 123456",
                                   "7555 123456"};
  normalize_phone_numbers(numbers, "44");
  for (auto const &number : numbers) {
    std::cout << number << std::endl;
  }
}
```

### 52. Generating all the permutations of a string

```c++

#include <iostream>
#include <string>
#include <algorithm>
void print_permutations(std::string str)
{
   std::sort(std::begin(str), std::end(str));
   do
   {
      std::cout << str << std::endl;
   } while (std::next_permutation(std::begin(str), std::end(str)));
}
void next_permutation(std::string str, std::string perm)
{
   if (str.empty()) std::cout << perm << std::endl;
   else
   {
      for (size_t i = 0; i < str.size(); ++i)
      {
         next_permutation(str.substr(1), perm + str[0]);
         std::rotate(std::begin(str), std::begin(str) + 1, std::end(str));
      }
   }
}
void print_permutations_recursive(std::string str)
{
   next_permutation(str, "");
}
int main()
{
   std::cout << "non-recursive version" << std::endl;
   print_permutations("main");
   std::cout << "recursive version" << std::endl;
   print_permutations_recursive("main");
}
```

### 53. Average rating of movies

```c++

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <numeric>
#include <iomanip>
struct movie {
  int id;
  std::string title;
  std::vector<int> ratings;
};
double truncated_mean(std::vector<int> values, double const percentage) {
  std::sort(std::begin(values), std::end(values));
  auto remove_count = static_cast<size_t>(values.size() * percentage + 0.5);
  values.erase(std::begin(values), std::begin(values) + remove_count);
  values.erase(std::end(values) - remove_count, std::end(values));
  auto total =
      std::accumulate(std::cbegin(values), std::cend(values), 0ull,
                      [](auto const sum, auto const e) { return sum + e; });
  return static_cast<double>(total) / values.size();
}
void print_movie_ratings(std::vector<movie> const &movies) {
  for (auto const &m : movies) {
    std::cout << m.title << " : " << std::fixed << std::setprecision(1)
              << truncated_mean(m.ratings, 0.05) << std::endl;
  }
}
int main() {
  std::vector<movie> movies{
      {101, "The Matrix", {10, 9, 10, 9, 9, 8, 7, 10, 5, 9, 9, 8}},
      {102, "Gladiator", {10, 5, 7, 8, 9, 8, 9, 10, 10, 5, 9, 8, 10}},
      {103, "Interstellar", {10, 10, 10, 9, 3, 8, 8, 9, 6, 4, 7, 10}}};
  print_movie_ratings(movies);
}
```

### 54. Pairwise algorithm

```c++

#include <iostream>
#include <vector>
template <typename Input, typename Output>
void pairwise(Input begin, Input end, Output result) {
  auto it = begin;
  while (it != end) {
    auto v1 = *it++;
    if (it == end)
      break;
    auto v2 = *it++;
    result++ = std::make_pair(v1, v2);
  }
}
template <typename T>
std::vector<std::pair<T, T>> pairwise(std::vector<T> const &range) {
  std::vector<std::pair<T, T>> result;
  pairwise(std::begin(range), std::end(range), std::back_inserter(result));
  return result;
}
int main() {
  std::vector<int> v{1, 1, 3, 5, 8, 13, 21};
  auto result = pairwise(v);
  for (auto const &p : result) {
    std::cout << '{' << p.first << ',' << p.second << '}' << std::endl;
  }
}
```

### 55. Zip algorithm

```c++

#include <iostream>
#include <vector>
template <typename Input1, typename Input2, typename Output>
void zip(Input1 begin1, Input1 end1, Input2 begin2, Input2 end2,
         Output result) {
  auto it1 = begin1;
  auto it2 = begin2;
  while (it1 != end1 && it2 != end2) {
    result++ = std::make_pair(*it1++, *it2++);
  }
}
template <typename T, typename U>
std::vector<std::pair<T, U>> zip(std::vector<T> const &range1,
                                 std::vector<U> const &range2) {
  std::vector<std::pair<T, U>> result;
  zip(std::begin(range1), std::end(range1), std::begin(range2),
      std::end(range2), std::back_inserter(result));
  return result;
}
int main() {
  std::vector<int> v1{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  std::vector<int> v2{1, 1, 3, 5, 8, 13, 21};
  auto result = zip(v1, v2);
  for (auto const &p : result) {
    std::cout << '{' << p.first << ',' << p.second << '}' << std::endl;
  }
}
```

### 56. Select algorithm

```c++

#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
template <typename T, typename A, typename F,
          typename R = typename std::decay<
              typename std::result_of<typename std::decay<F>::type &(
                  typename std::vector<T, A>::const_reference)>::type>::type>
std::vector<R> select(std::vector<T, A> const &c, F &&f) {
  std::vector<R> v;
  std::transform(std::cbegin(c), std::cend(c), std::back_inserter(v),
                 std::forward<F>(f));
  return v;
}
struct book {
  int id;
  std::string title;
  std::string author;
};
int main() {
  std::vector<book> books{
      {101, "The C++ Programming Language", "Bjarne Stroustrup"},
      {203, "Effective Modern C++", "Scott Meyers"},
      {404, "The Modern C++ Programming Cookbook", "Marius Bancila"}};
  auto titles = select(books, [](book const &b) { return b.title; });
  for (auto const &title : titles) {
    std::cout << title << std::endl;
  }
}
```

### 57. Sort algorithm

```c++

#include <iostream>
#include <vector>
#include <array>
#include <functional>
#include <numeric>
#include <random>
#include <array>
#include <stack>
#include <chrono>
#include <assert.h>
template <class RandomIt> RandomIt partition(RandomIt first, RandomIt last) {
  auto pivot = *first;
  auto i = first + 1;
  auto j = last - 1;
  while (i <= j) {
    while (i <= j && *i <= pivot)
      i++;
    while (i <= j && *j > pivot)
      j--;
    if (i < j)
      std::iter_swap(i, j);
  }
  std::iter_swap(i - 1, first);
  return i - 1;
}
template <class RandomIt, class Compare>
RandomIt partitionc(RandomIt first, RandomIt last, Compare comp) {
  auto pivot = *first;
  auto i = first + 1;
  auto j = last - 1;
  while (i <= j) {
    while (i <= j && comp(*i, pivot))
      i++;
    while (i <= j && !comp(*j, pivot))
      j--;
    if (i < j)
      std::iter_swap(i, j);
  }
  std::iter_swap(i - 1, first);
  return i - 1;
}
template <class RandomIt> void quicksorti(RandomIt first, RandomIt last) {
  std::stack<std::pair<RandomIt, RandomIt>> st;
  st.push(std::make_pair(first, last));
  while (!st.empty()) {
    auto iters = st.top();
    st.pop();
    if (iters.second - iters.first < 2)
      continue;
    auto p = partition(iters.first, iters.second);
    st.push(std::make_pair(iters.first, p));
    st.push(std::make_pair(p + 1, iters.second));
  }
}
template <class RandomIt> void quicksort(RandomIt first, RandomIt last) {
  if (first < last) {
    auto p = partition(first, last);
    quicksort(first, p);
    quicksort(p + 1, last);
  }
}
template <class RandomIt, class Compare>
void quicksort(RandomIt first, RandomIt last, Compare comp) {
  if (first < last) {
    auto p = partitionc(first, last, comp);
    quicksort(first, p, comp);
    quicksort(p + 1, last, comp);
  }
}
template <class RandomIt> void print(RandomIt first, RandomIt last) {
  for (auto it = first; it < last; ++it) {
    std::cout << *it << ' ';
  }
  std::cout << std::endl;
}
int main() {
  {
    std::vector<int> v{1, 5, 3, 8, 6, 2, 9, 7, 4};
    quicksort(std::begin(v), std::end(v));
    print(std::begin(v), std::end(v));
  }
  {
    std::array<int, 9> a{1, 2, 3, 4, 5, 6, 7, 8, 9};
    quicksort(std::begin(a), std::end(a));
    print(std::begin(a), std::end(a));
  }
  {
    int a[]{9, 8, 7, 6, 5, 4, 3, 2, 1};
    quicksort(std::begin(a), std::end(a));
    print(std::begin(a), std::end(a));
  }
  {
    std::vector<int> v{1, 5, 3, 8, 6, 2, 9, 7, 4};
    quicksort(std::begin(v), std::end(v), std::greater_equal<>());
    print(std::begin(v), std::end(v));
  }
  {
    std::array<int, 9> a{1, 2, 3, 4, 5, 6, 7, 8, 9};
    quicksort(std::begin(a), std::end(a), std::greater_equal<>());
    print(std::begin(a), std::end(a));
  }
  {
    int a[]{9, 8, 7, 6, 5, 4, 3, 2, 1};
    quicksort(std::begin(a), std::end(a), std::greater_equal<>());
    print(std::begin(a), std::end(a));
  }
  {
    std::vector<int> v{1, 5, 3, 8, 6, 2, 9, 7, 4};
    quicksorti(std::begin(v), std::end(v));
    print(std::begin(v), std::end(v));
  }
  {
    const size_t count = 1000000;
    std::vector<int> data(count);
    std::random_device rd;
    std::mt19937 mt;
    auto seed_data = std::array<int, std::mt19937::state_size>{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
    std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
    mt.seed(seq);
    std::uniform_int_distribution<> ud(1, 1000);
    std::cout << "generating..." << std::endl;
    std::generate_n(std::begin(data), count, [&mt, &ud]() { return ud(mt); });
    auto d1 = data;
    auto d2 = data;
    std::cout << "sorting..." << std::endl;
    auto start1 = std::chrono::system_clock::now();
    quicksort(std::begin(d1), std::end(d1));
    auto end1 = std::chrono::system_clock::now();
    auto t1 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    std::cout << "time: " << t1.count() << "ms" << std::endl;
    std::cout << "sorting..." << std::endl;
    auto start2 = std::chrono::system_clock::now();
    quicksorti(std::begin(d2), std::end(d2));
    auto end2 = std::chrono::system_clock::now();
    auto t2 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    std::cout << "time: " << t2.count() << "ms" << std::endl;
    assert(d1 == d2);
  }
}
```

### 58. The shortest path between nodes

```c++

#include <iostream>
#include <queue>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <numeric>
#include <string>
template <typename Vertex = int, typename Weight = double> class graph {
public:
  typedef Vertex vertex_type;
  typedef Weight weight_type;
  typedef std::pair<Vertex, Weight> neighbor_type;
  typedef std::vector<neighbor_type> neighbor_list_type;
public:
  void add_edge(Vertex const source, Vertex const target, Weight const weight,
                bool const bidirectional = true) {
    adjacency_list[source].push_back(std::make_pair(target, weight));
    adjacency_list[target].push_back(std::make_pair(source, weight));
  }
  size_t vertex_count() const { return adjacency_list.size(); }
  std::vector<Vertex> verteces() const {
    std::vector<Vertex> keys;
    for (auto const &kvp : adjacency_list)
      keys.push_back(kvp.first);
    return keys;
  }
  neighbor_list_type const &neighbors(Vertex const &v) const {
    auto pos = adjacency_list.find(v);
    if (pos == adjacency_list.end())
      throw std::runtime_error("vertex not found");
    return pos->second;
  }
  constexpr static Weight Infinity = std::numeric_limits<Weight>::infinity();
private:
  std::map<vertex_type, neighbor_list_type> adjacency_list;
};
template <typename Vertex, typename Weight>
void shortest_path(graph<Vertex, Weight> const &g, Vertex const source,
                   std::map<Vertex, Weight> &min_distance,
                   std::map<Vertex, Vertex> &previous) {
  auto const n = g.vertex_count();
  auto const verteces = g.verteces();
  min_distance.clear();
  for (auto const &v : verteces)
    min_distance[v] = graph<Vertex, Weight>::Infinity;
  min_distance[source] = 0;
  previous.clear();
  std::set<std::pair<Weight, Vertex>> vertex_queue;
  vertex_queue.insert(std::make_pair(min_distance[source], source));
  while (!vertex_queue.empty()) {
    auto dist = vertex_queue.begin()->first;
    auto u = vertex_queue.begin()->second;
    vertex_queue.erase(std::begin(vertex_queue));
    auto const &neighbors = g.neighbors(u);
    for (auto const &neighbor : neighbors) {
      auto v = neighbor.first;
      auto w = neighbor.second;
      auto dist_via_u = dist + w;
      if (dist_via_u < min_distance[v]) {
        vertex_queue.erase(std::make_pair(min_distance[v], v));
        min_distance[v] = dist_via_u;
        previous[v] = u;
        vertex_queue.insert(std::make_pair(min_distance[v], v));
      }
    }
  }
}
template <typename Vertex>
void build_path(std::map<Vertex, Vertex> const &prev, Vertex const v,
                std::vector<Vertex> &result) {
  result.push_back(v);
  auto pos = prev.find(v);
  if (pos == std::end(prev))
    return;
  build_path(prev, pos->second, result);
}
template <typename Vertex>
std::vector<Vertex> build_path(std::map<Vertex, Vertex> const &prev,
                               Vertex const v) {
  std::vector<Vertex> result;
  build_path(prev, v, result);
  std::reverse(std::begin(result), std::end(result));
  return result;
}
template <typename Vertex> void print_path(std::vector<Vertex> const &path) {
  for (size_t i = 0; i < path.size(); ++i) {
    std::cout << path[i];
    if (i < path.size() - 1)
      std::cout << " -> ";
  }
}
graph<char, double> make_graph() {
  graph<char, double> g;
  g.add_edge('A', 'B', 4);
  g.add_edge('A', 'H', 8);
  g.add_edge('B', 'C', 8);
  g.add_edge('B', 'H', 11);
  g.add_edge('C', 'D', 7);
  g.add_edge('C', 'F', 4);
  g.add_edge('C', 'J', 2);
  g.add_edge('D', 'E', 9);
  g.add_edge('D', 'F', 14);
  g.add_edge('E', 'F', 10);
  g.add_edge('F', 'G', 2);
  g.add_edge('G', 'J', 6);
  g.add_edge('G', 'H', 1);
  g.add_edge('H', 'J', 7);
  return g;
}
graph<char, double> make_graph_wiki() {
  graph<char, double> g;
  g.add_edge('A', 'B', 7);
  g.add_edge('A', 'C', 9);
  g.add_edge('A', 'F', 14);
  g.add_edge('B', 'C', 10);
  g.add_edge('B', 'D', 15);
  g.add_edge('C', 'D', 11);
  g.add_edge('C', 'F', 2);
  g.add_edge('D', 'E', 6);
  g.add_edge('E', 'F', 9);
  return g;
}
graph<std::string, double> make_graph_map() {
  graph<std::string, double> g;
  g.add_edge("London", "Reading", 41);
  g.add_edge("London", "Oxford", 57);
  g.add_edge("Reading", "Swindon", 40);
  g.add_edge("Swindon", "Bristol", 40);
  g.add_edge("Oxford", "Swindon", 30);
  g.add_edge("London", "Southampton", 80);
  g.add_edge("Southampton", "Bournemouth", 33);
  g.add_edge("Bournemouth", "Exeter", 89);
  g.add_edge("Bristol", "Exeter", 83);
  g.add_edge("Bristol", "Bath", 12);
  g.add_edge("Swindon", "Bath", 35);
  g.add_edge("Reading", "Southampton", 50);
  return g;
}
int main() {
  {
    auto g = make_graph();
    char source = 'A';
    std::map<char, double> min_distance;
    std::map<char, char> previous;
    shortest_path(g, source, min_distance, previous);
    for (auto const &kvp : min_distance) {
      std::cout << source << " -> " << kvp.first << " : " << kvp.second << '\t';
      print_path(build_path(previous, kvp.first));
      std::cout << std::endl;
    }
  }
  {
    auto g = make_graph_wiki();
    char source = 'A';
    std::map<char, double> min_distance;
    std::map<char, char> previous;
    shortest_path(g, source, min_distance, previous);
    for (auto const &kvp : min_distance) {
      std::cout << source << " -> " << kvp.first << " : " << kvp.second << '\t';
      print_path(build_path(previous, kvp.first));
      std::cout << std::endl;
    }
  }
  {
    auto g = make_graph_map();
    std::string source = "London";
    std::map<std::string, double> min_distance;
    std::map<std::string, std::string> previous;
    shortest_path(g, source, min_distance, previous);
    for (auto const &kvp : min_distance) {
      std::cout << source << " -> " << kvp.first << " : " << kvp.second << '\t';
      print_path(build_path(previous, kvp.first));
      std::cout << std::endl;
    }
  }
}
```

### 59. The Weasel program

```c++

#include <iostream>
#include <string>
#include <sstream>
#include <string_view>
#include <random>
#include <algorithm>
#include <array>
#include <iomanip>
#include <functional>
class weasel {
  std::string target;
  std::uniform_int_distribution<> chardist;
  std::uniform_real_distribution<> ratedist;
  std::mt19937 mt;
  std::string const allowed_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
public:
  weasel(std::string_view t) : target(t), chardist(0, 26), ratedist(0, 100) {
    std::random_device rd;
    auto seed_data = std::array<int, std::mt19937::state_size>{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
    std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
    mt.seed(seq);
  }
  void run(int const copies) {
    auto parent = make_random();
    int step = 1;
    std::cout << std::left << std::setw(5) << std::setfill(' ') << step
              << parent << std::endl;
    do {
      std::vector<std::string> children;
      std::generate_n(std::back_inserter(children), copies,
                      [parent, this]() { return mutate(parent, 5); });
      parent =
          *std::max_element(std::begin(children), std::end(children),
                            [this](std::string_view c1, std::string_view c2) {
                              return fitness(c1) < fitness(c2);
                            });
      std::cout << std::setw(5) << std::setfill(' ') << step << parent
                << std::endl;
      step++;
    } while (parent != target);
  }
private:
  weasel() = delete;
  double fitness(std::string_view candidate) {
    int score = 0;
    for (size_t i = 0; i < candidate.size(); ++i) {
      if (candidate[i] == target[i])
        score++;
    }
    return score;
  }
  std::string mutate(std::string_view parent, double const rate) {
    std::stringstream sstr;
    for (auto const c : parent) {
      auto nc = ratedist(mt) > rate ? c : allowed_chars[chardist(mt)];
      sstr << nc;
    }
    return sstr.str();
  }
  std::string make_random() {
    std::stringstream sstr;
    for (size_t i = 0; i < target.size(); ++i) {
      sstr << allowed_chars[chardist(mt)];
    }
    return sstr.str();
  }
};
int main() {
  weasel w("METHINKS IT IS LIKE A WEASEL");
  w.run(100);
}
```

### 60. The Game of Life

```c++

#include <iostream>
#include <vector>
#include <random>
#include <array>
#include <thread>
#include <chrono>
#include <functional>
class universe {
private:
  universe() = delete;
public:
  enum class seed { random, ten_cell_row, small_explorer, explorer };
public:
  universe(size_t const width, size_t const height)
      : rows(height), columns(width), grid(width * height), dist(0, 4) {
    std::random_device rd;
    auto seed_data = std::array<int, std::mt19937::state_size>{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
    std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
    mt.seed(seq);
  }
  void
  run(seed const s, int const generations,
      std::chrono::milliseconds const ms = std::chrono::milliseconds(100)) {
    reset();
    initialize(s);
    display();
    int i = 0;
    do {
      next_generation();
      display();
      using namespace std::chrono_literals;
      std::this_thread::sleep_for(ms);
    } while (i++ < generations || generations == 0);
  }
private:
  void next_generation() {
    std::vector<unsigned char> newgrid(grid.size());
    for (size_t r = 0; r < rows; ++r) {
      for (size_t c = 0; c < columns; ++c) {
        auto count = count_neighbors(r, c);
        if (cell(c, r) == alive) {
          newgrid[r * columns + c] = (count == 2 || count == 3) ? alive : dead;
        } else {
          newgrid[r * columns + c] = (count == 3) ? alive : dead;
        }
      }
    }
    grid.swap(newgrid);
  }
  void reset_display() {
#ifdef _WIN32
    system("cls");
#endif
  }
  void display() {
    reset_display();
    for (size_t r = 0; r < rows; ++r) {
      for (size_t c = 0; c < columns; ++c) {
        std::cout << (cell(c, r) ? '*' : ' ');
      }
      std::cout << std::endl;
    }
  }
  void initialize(seed const s) {
    if (s == seed::small_explorer) {
      auto mr = rows / 2;
      auto mc = columns / 2;
      cell(mc, mr) = alive;
      cell(mc - 1, mr + 1) = alive;
      cell(mc, mr + 1) = alive;
      cell(mc + 1, mr + 1) = alive;
      cell(mc - 1, mr + 2) = alive;
      cell(mc + 1, mr + 2) = alive;
      cell(mc, mr + 3) = alive;
    } else if (s == seed::explorer) {
      auto mr = rows / 2;
      auto mc = columns / 2;
      cell(mc - 2, mr - 2) = alive;
      cell(mc, mr - 2) = alive;
      cell(mc + 2, mr - 2) = alive;
      cell(mc - 2, mr - 1) = alive;
      cell(mc + 2, mr - 1) = alive;
      cell(mc - 2, mr) = alive;
      cell(mc + 2, mr) = alive;
      cell(mc - 2, mr + 1) = alive;
      cell(mc + 2, mr + 1) = alive;
      cell(mc - 2, mr + 2) = alive;
      cell(mc, mr - 2) = alive;
      cell(mc + 2, mr + 2) = alive;
    } else if (s == seed::ten_cell_row) {
      for (size_t c = columns / 2 - 5; c < columns / 2 + 5; c++)
        cell(c, rows / 2) = alive;
    } else {
      for (size_t r = 0; r < rows; ++r) {
        for (size_t c = 0; c < columns; ++c) {
          cell(c, r) = dist(mt) == 0 ? alive : dead;
        }
      }
    }
  }
  void reset() {
    for (size_t r = 0; r < rows; ++r) {
      for (size_t c = 0; c < columns; ++c) {
        cell(c, r) = dead;
      }
    }
  }
  int count_alive() { return 0; }
  template <typename T1, typename... T> auto count_alive(T1 s, T... ts) {
    return s + count_alive(ts...);
  }
  int count_neighbors(size_t const row, size_t const col) {
    if (row == 0 && col == 0)
      return count_alive(cell(1, 0), cell(1, 1), cell(0, 1));
    if (row == 0 && col == columns - 1)
      return count_alive(cell(columns - 2, 0), cell(columns - 2, 1),
                         cell(columns - 1, 1));
    if (row == rows - 1 && col == 0)
      return count_alive(cell(0, rows - 2), cell(1, rows - 2),
                         cell(1, rows - 1));
    if (row == rows - 1 && col == columns - 1)
      return count_alive(cell(columns - 1, rows - 2),
                         cell(columns - 2, rows - 2),
                         cell(columns - 2, rows - 1));
    if (row == 0 && col > 0 && col < columns - 1)
      return count_alive(cell(col - 1, 0), cell(col - 1, 1), cell(col, 1),
                         cell(col + 1, 1), cell(col + 1, 0));
    if (row == rows - 1 && col > 0 && col < columns - 1)
      return count_alive(cell(col - 1, row), cell(col - 1, row - 1),
                         cell(col, row - 1), cell(col + 1, row - 1),
                         cell(col + 1, row));
    if (col == 0 && row > 0 && row < rows - 1)
      return count_alive(cell(0, row - 1), cell(1, row - 1), cell(1, row),
                         cell(1, row + 1), cell(0, row + 1));
    if (col == columns - 1 && row > 0 && row < rows - 1)
      return count_alive(cell(col, row - 1), cell(col - 1, row - 1),
                         cell(col - 1, row), cell(col - 1, row + 1),
                         cell(col, row + 1));
    return count_alive(cell(col - 1, row - 1), cell(col, row - 1),
                       cell(col + 1, row - 1), cell(col + 1, row),
                       cell(col + 1, row + 1), cell(col, row + 1),
                       cell(col - 1, row + 1), cell(col - 1, row));
  }
  unsigned char &cell(size_t const col, size_t const row) {
    return grid[row * columns + col];
  }
private:
  size_t rows;
  size_t columns;
  std::vector<unsigned char> grid;
  const unsigned char alive = 1;
  const unsigned char dead = 0;
  std::uniform_int_distribution<> dist;
  std::mt19937 mt;
};
int main() {
  using namespace std::chrono_literals;
  universe u(50, 20);
  u.run(universe::seed::random, 100, 100ms);
}
```

## Concurrency

### 61. Parallel transform algorithm

```c++

#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <functional>
#include <random>
#include <chrono>
#include <thread>
#include <assert.h>
template <typename T, typename F>
std::vector<T> alter(std::vector<T> data, F &&f) {
  std::transform(std::begin(data), std::end(data), std::begin(data),
                 std::forward<F>(f));
  return data;
}
template <typename T, typename F>
std::vector<T> palter(std::vector<T> data, F &&f) {
  if (data.size() <= 10000) {
    std::transform(std::begin(data), std::end(data), std::begin(data),
                   std::forward<F>(f));
  } else {
    std::vector<std::thread> threads;
    int thread_count = std::thread::hardware_concurrency();
    auto first = std::begin(data);
    auto last = first;
    auto size = data.size() / thread_count;
    for (int i = 0; i < thread_count; ++i) {
      first = last;
      last = i == thread_count - 1 ? std::end(data) : first + size;
      threads.emplace_back([first, last, &f]() {
        std::transform(first, last, first, std::forward<F>(f));
      });
    }
    for (int i = 0; i < thread_count; ++i)
      threads[i].join();
  }
  return data;
}
template <typename RandomAccessIterator, typename F>
void ptransform(RandomAccessIterator begin, RandomAccessIterator end, F &&f) {
  auto size = std::distance(begin, end);
  if (size <= 10000) {
    std::transform(begin, end, begin, std::forward<F>(f));
  } else {
    std::vector<std::thread> threads;
    int thread_count = 10;
    auto first = begin;
    auto last = first;
    size /= thread_count;
    for (int i = 0; i < thread_count; ++i) {
      first = last;
      if (i == thread_count - 1)
        last = end;
      else
        std::advance(last, size);
      threads.emplace_back([first, last, &f]() {
        std::transform(first, last, first, std::forward<F>(f));
      });
    }
    for (auto &t : threads)
      t.join();
  }
}
template <typename T, typename F>
std::vector<T> palter2(std::vector<T> data, F &&f) {
  ptransform(std::begin(data), std::end(data), std::forward<F>(f));
  return data;
}
int main() {
  const size_t count = 10000000;
  std::vector<int> data(count);
  std::random_device rd;
  std::mt19937 mt;
  auto seed_data = std::array<int, std::mt19937::state_size>{};
  std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
  std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
  mt.seed(seq);
  std::uniform_int_distribution<> ud(1, 100);
  std::generate_n(std::begin(data), count, [&mt, &ud]() { return ud(mt); });
  auto start = std::chrono::system_clock::now();
  auto r1 = alter(data, [](int const e) { return e * e; });
  auto end = std::chrono::system_clock::now();
  auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  std::cout << "time: " << t1.count() << "ms" << std::endl;
  start = std::chrono::system_clock::now();
  auto r2 = palter(data, [](int const e) { return e * e; });
  end = std::chrono::system_clock::now();
  auto t2 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  std::cout << "time: " << t2.count() << "ms" << std::endl;
  start = std::chrono::system_clock::now();
  auto r3 = palter2(data, [](int const e) { return e * e; });
  end = std::chrono::system_clock::now();
  auto t3 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  std::cout << "time: " << t3.count() << "ms" << std::endl;
  assert(r1 == r2);
  assert(r1 == r3);
}
```

### 62. Parallel min and max element algorithms using threads

```c++

#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <functional>
#include <random>
#include <chrono>
#include <thread>
#include <assert.h>
template <typename Iterator, typename F>
auto sprocess(Iterator begin, Iterator end, F &&f) {
  return std::forward<F>(f)(begin, end);
}
template <typename Iterator> auto smin(Iterator begin, Iterator end) {
  return sprocess(begin, end,
                  [](auto b, auto e) { return *std::min_element(b, e); });
}
template <typename Iterator> auto smax(Iterator begin, Iterator end) {
  return sprocess(begin, end,
                  [](auto b, auto e) { return *std::max_element(b, e); });
}
template <typename Iterator, typename F>
auto pprocess(Iterator begin, Iterator end, F &&f) {
  auto size = std::distance(begin, end);
  if (size <= 10000) {
    return std::forward<F>(f)(begin, end);
  } else {
    int thread_count = std::thread::hardware_concurrency();
    std::vector<std::thread> threads;
    std::vector<typename std::iterator_traits<Iterator>::value_type> mins(
        thread_count);
    auto first = begin;
    auto last = first;
    size /= thread_count;
    for (int i = 0; i < thread_count; ++i) {
      first = last;
      if (i == thread_count - 1)
        last = end;
      else
        std::advance(last, size);
      threads.emplace_back([first, last, &f, &r = mins[i]]() {
        r = std::forward<F>(f)(first, last);
      });
    }
    for (auto &t : threads)
      t.join();
    return std::forward<F>(f)(std::begin(mins), std::end(mins));
  }
}
template <typename Iterator> auto pmin(Iterator begin, Iterator end) {
  return pprocess(begin, end,
                  [](auto b, auto e) { return *std::min_element(b, e); });
}
template <typename Iterator> auto pmax(Iterator begin, Iterator end) {
  return pprocess(begin, end,
                  [](auto b, auto e) { return *std::max_element(b, e); });
}
int main() {
  const size_t count = 10000000;
  std::vector<int> data(count);
  std::random_device rd;
  std::mt19937 mt;
  auto seed_data = std::array<int, std::mt19937::state_size>{};
  std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
  std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
  mt.seed(seq);
  std::uniform_int_distribution<> ud(1, 1000);
  std::generate_n(std::begin(data), count, [&mt, &ud]() { return ud(mt); });
  {
    std::cout << "minimum element" << std::endl;
    auto start = std::chrono::system_clock::now();
    auto r1 = smin(std::begin(data), std::end(data));
    auto end = std::chrono::system_clock::now();
    auto t1 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "seq time: " << t1.count() << "ms" << std::endl;
    start = std::chrono::system_clock::now();
    auto r2 = pmin(std::begin(data), std::end(data));
    end = std::chrono::system_clock::now();
    auto t2 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "par time: " << t2.count() << "ms" << std::endl;
    assert(r1 == r2);
  }
  {
    std::cout << "maximum element" << std::endl;
    auto start = std::chrono::system_clock::now();
    auto r1 = smax(std::begin(data), std::end(data));
    auto end = std::chrono::system_clock::now();
    auto t1 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "seq time: " << t1.count() << "ms" << std::endl;
    start = std::chrono::system_clock::now();
    auto r2 = pmax(std::begin(data), std::end(data));
    end = std::chrono::system_clock::now();
    auto t2 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "par time: " << t2.count() << "ms" << std::endl;
    assert(r1 == r2);
  }
}
```

### 63. Parallel min and max element algorithms using asynchronous functions

```c++

#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <functional>
#include <random>
#include <chrono>
#include <future>
#include <assert.h>
template <typename Iterator, typename F>
auto sprocess(Iterator begin, Iterator end, F &&f) {
  return std::forward<F>(f)(begin, end);
}
template <typename Iterator> auto smin(Iterator begin, Iterator end) {
  return sprocess(begin, end,
                  [](auto b, auto e) { return *std::min_element(b, e); });
}
template <typename Iterator> auto smax(Iterator begin, Iterator end) {
  return sprocess(begin, end,
                  [](auto b, auto e) { return *std::max_element(b, e); });
}
template <typename Iterator, typename F>
auto pprocess(Iterator begin, Iterator end, F &&f) {
  auto size = std::distance(begin, end);
  if (size <= 10000) {
    return std::forward<F>(f)(begin, end);
  } else {
    int task_count = std::thread::hardware_concurrency();
    std::vector<
        std::future<typename std::iterator_traits<Iterator>::value_type>>
        tasks;
    auto first = begin;
    auto last = first;
    size /= task_count;
    for (int i = 0; i < task_count; ++i) {
      first = last;
      if (i == task_count - 1)
        last = end;
      else
        std::advance(last, size);
      tasks.emplace_back(std::async(std::launch::async, [first, last, &f]() {
        return std::forward<F>(f)(first, last);
      }));
    }
    std::vector<typename std::iterator_traits<Iterator>::value_type> mins;
    for (auto &t : tasks)
      mins.push_back(t.get());
    return std::forward<F>(f)(std::begin(mins), std::end(mins));
  }
}
template <typename Iterator> auto pmin(Iterator begin, Iterator end) {
  return pprocess(begin, end,
                  [](auto b, auto e) { return *std::min_element(b, e); });
}
template <typename Iterator> auto pmax(Iterator begin, Iterator end) {
  return pprocess(begin, end,
                  [](auto b, auto e) { return *std::max_element(b, e); });
}
int main() {
  const size_t count = 10000000;
  std::vector<int> data(count);
  std::random_device rd;
  std::mt19937 mt;
  auto seed_data = std::array<int, std::mt19937::state_size>{};
  std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
  std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
  mt.seed(seq);
  std::uniform_int_distribution<> ud(1, 1000);
  std::generate_n(std::begin(data), count, [&mt, &ud]() { return ud(mt); });
  {
    std::cout << "minimum element" << std::endl;
    auto start = std::chrono::system_clock::now();
    auto r1 = smin(std::begin(data), std::end(data));
    auto end = std::chrono::system_clock::now();
    auto t1 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "seq time: " << t1.count() << "ms" << std::endl;
    start = std::chrono::system_clock::now();
    auto r2 = pmin(std::begin(data), std::end(data));
    end = std::chrono::system_clock::now();
    auto t2 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "par time: " << t2.count() << "ms" << std::endl;
    assert(r1 == r2);
  }
  {
    std::cout << "maximum element" << std::endl;
    auto start = std::chrono::system_clock::now();
    auto r1 = smax(std::begin(data), std::end(data));
    auto end = std::chrono::system_clock::now();
    auto t1 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "seq time: " << t1.count() << "ms" << std::endl;
    start = std::chrono::system_clock::now();
    auto r2 = pmax(std::begin(data), std::end(data));
    end = std::chrono::system_clock::now();
    auto t2 =
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "par time: " << t2.count() << "ms" << std::endl;
    assert(r1 == r2);
  }
}
```

### 64. Parallel sort algorithm

```c++

#include <iostream>
#include <vector>
#include <array>
#include <functional>
#include <chrono>
#include <assert.h>
#include <random>
#include <future>
template <class RandomIt> RandomIt partition(RandomIt first, RandomIt last) {
  auto pivot = *first;
  auto i = first + 1;
  auto j = last - 1;
  while (i <= j) {
    while (i <= j && *i <= pivot)
      i++;
    while (i <= j && *j > pivot)
      j--;
    if (i < j)
      std::iter_swap(i, j);
  }
  std::iter_swap(i - 1, first);
  return i - 1;
}
template <class RandomIt, class Compare>
RandomIt partitionc(RandomIt first, RandomIt last, Compare comp) {
  auto pivot = *first;
  auto i = first + 1;
  auto j = last - 1;
  while (i <= j) {
    while (i <= j && comp(*i, pivot))
      i++;
    while (i <= j && !comp(*j, pivot))
      j--;
    if (i < j)
      std::iter_swap(i, j);
  }
  std::iter_swap(i - 1, first);
  return i - 1;
}
template <class RandomIt> void quicksort(RandomIt first, RandomIt last) {
  if (first < last) {
    auto p = partition(first, last);
    quicksort(first, p);
    quicksort(p + 1, last);
  }
}
template <class RandomIt, class Compare>
void quicksort(RandomIt first, RandomIt last, Compare comp) {
  if (first < last) {
    auto p = partitionc(first, last, comp);
    quicksort(first, p, comp);
    quicksort(p + 1, last, comp);
  }
}
template <class RandomIt> void pquicksort(RandomIt first, RandomIt last) {
  if (first < last) {
    auto p = partition(first, last);
    if (last - first <= 100000) {
      pquicksort(first, p);
      pquicksort(p + 1, last);
    } else {
      auto f1 = std::async(std::launch::async,
                           [first, p]() { pquicksort(first, p); });
      auto f2 = std::async(std::launch::async,
                           [last, p]() { pquicksort(p + 1, last); });
      f1.wait();
      f2.wait();
    }
  }
}
int main() {
  const size_t count = 1000000;
  std::vector<int> data(count);
  std::random_device rd;
  std::mt19937 mt;
  auto seed_data = std::array<int, std::mt19937::state_size>{};
  std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
  std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
  mt.seed(seq);
  std::uniform_int_distribution<> ud(1, 1000);
  std::cout << "generating..." << std::endl;
  std::generate_n(std::begin(data), count, [&mt, &ud]() { return ud(mt); });
  auto d1 = data;
  auto d2 = data;
  std::cout << "sorting..." << std::endl;
  auto start = std::chrono::system_clock::now();
  quicksort(std::begin(d1), std::end(d1));
  auto end = std::chrono::system_clock::now();
  auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  std::cout << "time: " << t1.count() << "ms" << std::endl;
  start = std::chrono::system_clock::now();
  pquicksort(std::begin(d2), std::end(d2));
  end = std::chrono::system_clock::now();
  auto t2 = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  std::cout << "time: " << t2.count() << "ms" << std::endl;
  std::cout << "verifying..." << std::endl;
  assert(d1 == d2);
}
```

### 65. Thread-safe logging to the console

```c++

#include <iostream>
#include <vector>
#include <chrono>
#include <random>
#include <thread>
#include <string_view>
#include <mutex>
#include <string>
class logger {
protected:
  logger() {}
public:
  static logger &instance() {
    static logger lg;
    return lg;
  }
  logger(logger const &) = delete;
  logger &operator=(logger const &) = delete;
  void log(std::string_view message) {
    std::lock_guard<std::mutex> lock(mt);
    std::cout << "LOG: " << message << std::endl;
  }
private:
  std::mutex mt;
};
int main() {
  std::vector<std::thread> modules;
  for (int id = 1; id <= 5; ++id) {
    modules.emplace_back([id]() {
      std::random_device rd;
      std::mt19937 mt(rd());
      std::uniform_int_distribution<> ud(100, 1000);
      logger::instance().log("module " + std::to_string(id) + " started");
      std::this_thread::sleep_for(std::chrono::milliseconds(ud(mt)));
      logger::instance().log("module " + std::to_string(id) + " finished");
    });
  }
  for (auto &m : modules)
    m.join();
}
```

### 66. Customer service system

```c++

#include <iostream>
#include <vector>
#include <chrono>
#include <random>
#include <thread>
#include <string_view>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <string>
#include <array>
#include <functional>
class logger {
protected:
  logger() {}
public:
  static logger &instance() {
    static logger lg;
    return lg;
  }
  logger(logger const &) = delete;
  logger &operator=(logger const &) = delete;
  void log(std::string_view message) {
    std::lock_guard<std::mutex> lock(mt);
    std::cout << "LOG: " << message << std::endl;
  }
private:
  std::mutex mt;
};
class ticketing_machine {
public:
  ticketing_machine(int const start)
      : last_ticket(start), first_ticket(start) {}
  int next() { return last_ticket++; }
  int last() const { return last_ticket - 1; }
  void reset() { last_ticket = first_ticket; }
private:
  int first_ticket;
  int last_ticket;
};
class customer {
public:
  customer(int const no) : number(no) {}
  int ticket_number() const noexcept { return number; }
private:
  int number;
  friend bool operator<(customer const &l, customer const &r);
};
bool operator<(customer const &l, customer const &r) {
  return l.number > r.number;
}
int main() {
  std::priority_queue<customer> customers;
  bool store_open = true;
  std::mutex mt;
  std::condition_variable cv;
  std::vector<std::thread> desks;
  for (int i = 1; i <= 3; ++i) {
    desks.emplace_back([i, &store_open, &mt, &cv, &customers]() {
      std::random_device rd;
      auto seed_data = std::array<int, std::mt19937::state_size>{};
      std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
      std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
      std::mt19937 eng(seq);
      std::uniform_int_distribution<> ud(2000, 3000);
      logger::instance().log("desk " + std::to_string(i) + " open");
      while (store_open || !customers.empty()) {
        std::unique_lock<std::mutex> locker(mt);
        cv.wait_for(locker, std::chrono::seconds(1),
                    [&customers]() { return !customers.empty(); });
        if (!customers.empty()) {
          auto const c = customers.top();
          customers.pop();
          logger::instance().log("[-] desk " + std::to_string(i) +
                                 " handling customer " +
                                 std::to_string(c.ticket_number()));
          logger::instance().log("[=] queue size: " +
                                 std::to_string(customers.size()));
          locker.unlock();
          cv.notify_one();
          std::this_thread::sleep_for(std::chrono::milliseconds(ud(eng)));
          logger::instance().log("[ ] desk " + std::to_string(i) +
                                 " done with customer " +
                                 std::to_string(c.ticket_number()));
        }
      }
      logger::instance().log("desk " + std::to_string(i) + " closed");
    });
  }
  std::thread store([&store_open, &customers, &mt, &cv]() {
    ticketing_machine tm(100);
    std::random_device rd;
    auto seed_data = std::array<int, std::mt19937::state_size>{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
    std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
    std::mt19937 eng(seq);
    std::uniform_int_distribution<> ud(200, 500);
    for (int i = 1; i <= 25; ++i) {
      customer c(tm.next());
      customers.push(c);
      logger::instance().log("[+] new customer with ticket " +
                             std::to_string(c.ticket_number()));
      logger::instance().log("[=] queue size: " +
                             std::to_string(customers.size()));
      cv.notify_one();
      std::this_thread::sleep_for(std::chrono::milliseconds(ud(eng)));
    }
    store_open = false;
  });
  store.join();
  for (auto &desk : desks)
    desk.join();
}
```

## Design Patterns

### 67. Validating passwords

```c++

#include <string>
#include <string_view>
#include <memory>
#include <assert.h>
class password_validator {
public:
  virtual bool validate(std::string_view password) = 0;
  virtual ~password_validator() {}
};
class length_validator final : public password_validator {
public:
  length_validator(unsigned int min_length) : length(min_length) {}
  virtual bool validate(std::string_view password) override {
    return password.length() >= length;
  }
private:
  unsigned int length;
};
class password_validator_decorator : public password_validator {
public:
  explicit password_validator_decorator(
      std::unique_ptr<password_validator> validator)
      : inner(std::move(validator)) {}
  virtual bool validate(std::string_view password) override {
    return inner->validate(password);
  }
private:
  std::unique_ptr<password_validator> inner;
};
class digit_password_validator final : public password_validator_decorator {
public:
  explicit digit_password_validator(
      std::unique_ptr<password_validator> validator)
      : password_validator_decorator(std::move(validator)) {}
  virtual bool validate(std::string_view password) override {
    if (!password_validator_decorator::validate(password))
      return false;
    return password.find_first_of("0123456789") != std::string::npos;
  }
};
class case_password_validator final : public password_validator_decorator {
public:
  explicit case_password_validator(
      std::unique_ptr<password_validator> validator)
      : password_validator_decorator(std::move(validator)) {}
  virtual bool validate(std::string_view password) override {
    if (!password_validator_decorator::validate(password))
      return false;
    bool haslower = false;
    bool hasupper = false;
    for (size_t i = 0; i < password.length() && !(hasupper && haslower); ++i) {
      if (islower(password[i]))
        haslower = true;
      else if (isupper(password[i]))
        hasupper = true;
    }
    return haslower && hasupper;
  }
};
class symbol_password_validator final : public password_validator_decorator {
public:
  explicit symbol_password_validator(
      std::unique_ptr<password_validator> validator)
      : password_validator_decorator(std::move(validator)) {}
  virtual bool validate(std::string_view password) override {
    if (!password_validator_decorator::validate(password))
      return false;
    return password.find_first_of("!@#$%^&*(){}[]?<>") != std::string::npos;
  }
};
int main() {
  {
    auto validator = std::make_unique<length_validator>(8);
    assert(validator->validate("abc123!@#"));
    assert(!validator->validate("abc123"));
  }
  {
    auto validator = std::make_unique<digit_password_validator>(
        std::make_unique<length_validator>(8));
    assert(validator->validate("abc123!@#"));
    assert(!validator->validate("abcde!@#"));
  }
  {
    auto validator = std::make_unique<case_password_validator>(
        std::make_unique<digit_password_validator>(
            std::make_unique<length_validator>(8)));
    assert(validator->validate("Abc123!@#"));
    assert(!validator->validate("abc123!@#"));
  }
  {
    auto validator = std::make_unique<symbol_password_validator>(
        std::make_unique<case_password_validator>(
            std::make_unique<digit_password_validator>(
                std::make_unique<length_validator>(8))));
    assert(validator->validate("Abc123!@#"));
    assert(!validator->validate("Abc123567"));
  }
}
```

### 68. Generating random passwords

```c++

#include <iostream>
#include <string>
#include <memory>
#include <random>
#include <array>
#include <algorithm>
class password_generator {
public:
  virtual std::string generate() = 0;
  virtual std::string allowed_chars() const = 0;
  virtual size_t length() const = 0;
  virtual void add(std::unique_ptr<password_generator> generator) = 0;
  virtual ~password_generator() {}
};
class basic_password_generator : public password_generator {
  size_t len;
public:
  explicit basic_password_generator(size_t const len) noexcept : len(len) {}
  virtual std::string generate() override {
    throw std::runtime_error("not implemented");
  }
  virtual void add(std::unique_ptr<password_generator>) override {
    throw std::runtime_error("not implemented");
  }
  virtual size_t length() const noexcept override final { return len; }
};
class digit_generator : public basic_password_generator {
public:
  explicit digit_generator(size_t const len) noexcept
      : basic_password_generator(len) {}
  virtual std::string allowed_chars() const override { return "0123456789"; }
};
class symbol_generator : public basic_password_generator {
public:
  explicit symbol_generator(size_t const len) noexcept
      : basic_password_generator(len) {}
  virtual std::string allowed_chars() const override {
    return "!@#$%^&*(){}[]?<>";
  }
};
class upper_letter_generator : public basic_password_generator {
public:
  explicit upper_letter_generator(size_t const len) noexcept
      : basic_password_generator(len) {}
  virtual std::string allowed_chars() const override {
    return "ABCDEFGHIJKLMNOPQRSTUVXYWZ";
  }
};
class lower_letter_generator : public basic_password_generator {
public:
  explicit lower_letter_generator(size_t const len) noexcept
      : basic_password_generator(len) {}
  virtual std::string allowed_chars() const override {
    return "abcdefghijklmnopqrstuvxywz";
  }
};
class composite_password_generator : public password_generator {
  virtual std::string allowed_chars() const override {
    throw std::runtime_error("not implemented");
  };
  virtual size_t length() const override {
    throw std::runtime_error("not implemented");
  };
public:
  composite_password_generator() {
    auto seed_data = std::array<int, std::mt19937::state_size>{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
    std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
    eng.seed(seq);
  }
  virtual std::string generate() override {
    std::string password;
    for (auto &generator : generators) {
      std::string chars = generator->allowed_chars();
      std::uniform_int_distribution<> ud(0,
                                         static_cast<int>(chars.length() - 1));
      for (size_t i = 0; i < generator->length(); ++i)
        password += chars[ud(eng)];
    }
    std::shuffle(std::begin(password), std::end(password), eng);
    return password;
  }
  virtual void add(std::unique_ptr<password_generator> generator) override {
    generators.push_back(std::move(generator));
  }
private:
  std::random_device rd;
  std::mt19937 eng;
  std::vector<std::unique_ptr<password_generator>> generators;
};
int main() {
  composite_password_generator generator;
  generator.add(std::make_unique<symbol_generator>(2));
  generator.add(std::make_unique<digit_generator>(2));
  generator.add(std::make_unique<upper_letter_generator>(2));
  generator.add(std::make_unique<lower_letter_generator>(4));
  auto password = generator.generate();
  std::cout << password << std::endl;
}
```

### 69. Generating social security numbers

```c++

#include <iostream>
#include <string>
#include <sstream>
#include <string_view>
#include <random>
#include <array>
#include <map>
#include <memory>
#include <algorithm>
#include <numeric>
#include <assert.h>
enum class sex_type { female, male };
class social_number_generator {
protected:
  virtual int sex_digit(sex_type const sex) const noexcept = 0;
  virtual int next_random(unsigned const year, unsigned const month,
                          unsigned const day) = 0;
  virtual int modulo_value() const noexcept = 0;
  social_number_generator(int const min, int const max) : ud(min, max) {
    std::random_device rd;
    auto seed_data = std::array<int, std::mt19937::state_size>{};
    std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
    std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
    eng.seed(seq);
  }
public:
  std::string generate(sex_type const sex, unsigned const year,
                       unsigned const month, unsigned const day) {
    std::stringstream snumber;
    snumber << sex_digit(sex);
    snumber << year << month << day;
    snumber << next_random(year, month, day);
    auto number = snumber.str();
    auto index = number.length();
    auto sum = std::accumulate(std::begin(number), std::end(number), 0u,
                               [&index](unsigned int const s, char const c) {
                                 return s + static_cast<unsigned int>(
                                                index-- * (c - '0'));
                               });
    auto rest = sum % modulo_value();
    snumber << modulo_value() - rest;
    return snumber.str();
  }
  virtual ~social_number_generator() {}
protected:
  std::map<unsigned, int> cache;
  std::mt19937 eng;
  std::uniform_int_distribution<> ud;
};
class southeria_social_number_generator final : public social_number_generator {
public:
  southeria_social_number_generator() : social_number_generator(1000, 9999) {}
protected:
  virtual int sex_digit(sex_type const sex) const noexcept override {
    if (sex == sex_type::female)
      return 1;
    else
      return 2;
  }
  virtual int next_random(unsigned const year, unsigned const month,
                          unsigned const day) override {
    auto key = year * 10000 + month * 100 + day;
    while (true) {
      auto number = ud(eng);
      auto pos = cache.find(number);
      if (pos == std::end(cache)) {
        cache[key] = number;
        return number;
      }
    }
  }
  virtual int modulo_value() const noexcept override { return 11; }
};
class northeria_social_number_generator final : public social_number_generator {
public:
  northeria_social_number_generator() : social_number_generator(10000, 99999) {}
protected:
  virtual int sex_digit(sex_type const sex) const noexcept override {
    if (sex == sex_type::female)
      return 9;
    else
      return 7;
  }
  virtual int next_random(unsigned const year, unsigned const month,
                          unsigned const day) override {
    auto key = year * 10000 + month * 100 + day;
    while (true) {
      auto number = ud(eng);
      auto pos = cache.find(number);
      if (pos == std::end(cache)) {
        cache[key] = number;
        return number;
      }
    }
  }
  virtual int modulo_value() const noexcept override { return 11; }
};
class social_number_generator_factory {
public:
  social_number_generator_factory() {
    generators["northeria"] =
        std::make_unique<northeria_social_number_generator>();
    generators["southeria"] =
        std::make_unique<southeria_social_number_generator>();
  }
  social_number_generator *get_generator(std::string_view country) const {
    auto it = generators.find(country.data());
    if (it != std::end(generators))
      return it->second.get();
    throw std::runtime_error("invalid country");
  }
private:
  std::map<std::string, std::unique_ptr<social_number_generator>> generators;
};
int main() {
  social_number_generator_factory factory;
  auto sn1 = factory.get_generator("northeria")
                 ->generate(sex_type::female, 2017, 12, 25);
  auto sn2 = factory.get_generator("northeria")
                 ->generate(sex_type::female, 2017, 12, 25);
  auto sn3 = factory.get_generator("northeria")
                 ->generate(sex_type::male, 2017, 12, 25);
  auto ss1 = factory.get_generator("southeria")
                 ->generate(sex_type::female, 2017, 12, 25);
  auto ss2 = factory.get_generator("southeria")
                 ->generate(sex_type::female, 2017, 12, 25);
  auto ss3 = factory.get_generator("southeria")
                 ->generate(sex_type::male, 2017, 12, 25);
}
```

### 70. Approval system

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <memory>
class role {
public:
  virtual double approval_limit() const noexcept = 0;
  virtual ~role() {}
};
class employee_role : public role {
public:
  virtual double approval_limit() const noexcept override { return 1000; }
};
class team_manager_role : public role {
public:
  virtual double approval_limit() const noexcept override { return 10000; }
};
class department_manager_role : public role {
public:
  virtual double approval_limit() const noexcept override { return 100000; }
};
class president_role : public role {
public:
  virtual double approval_limit() const noexcept override {
    return std::numeric_limits<double>::max();
  }
};
struct expense {
  double amount;
  std::string description;
  expense(double const amount, std::string_view desc)
      : amount(amount), description(desc) {}
};
class employee {
public:
  explicit employee(std::string_view name, std::unique_ptr<role> ownrole)
      : name(name), own_role(std::move(ownrole)) {}
  void set_direct_manager(std::shared_ptr<employee> manager) {
    direct_manager = manager;
  }
  void approve(expense const &e) {
    if (e.amount <= own_role->approval_limit())
      std::cout << name << " approved expense '" << e.description
                << "', cost=" << e.amount << std::endl;
    else if (direct_manager != nullptr)
      direct_manager->approve(e);
  }
private:
  std::string name;
  std::unique_ptr<role> own_role;
  std::shared_ptr<employee> direct_manager;
};
int main() {
  auto john = std::make_shared<employee>("john smith",
                                         std::make_unique<employee_role>());
  auto robert = std::make_shared<employee>(
      "robert booth", std::make_unique<team_manager_role>());
  auto david = std::make_shared<employee>(
      "david jones", std::make_unique<department_manager_role>());
  auto cecil = std::make_shared<employee>("cecil williamson",
                                          std::make_unique<president_role>());
  john->set_direct_manager(robert);
  robert->set_direct_manager(david);
  david->set_direct_manager(cecil);
  john->approve(expense{500, "magazins"});
  john->approve(expense{5000, "hotel accomodation"});
  john->approve(expense{50000, "conference costs"});
  john->approve(expense{200000, "new lorry"});
}
```

### 71. Observable vector container

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <algorithm>
enum class collection_action { add, remove, clear, assign };
std::string to_string(collection_action const action) {
  switch (action) {
  case collection_action::add:
    return "add";
  case collection_action::remove:
    return "remove";
  case collection_action::clear:
    return "clear";
  case collection_action::assign:
    return "assign";
  }
}
struct collection_change_notification {
  collection_action action;
  std::vector<size_t> item_indexes;
};
class collection_observer {
public:
  virtual void
  collection_changed(collection_change_notification notification) = 0;
  virtual ~collection_observer() {}
};
template <typename T, class Allocator = std::allocator<T>>
class observable_vector final {
  typedef typename std::vector<T, Allocator>::size_type size_type;
public:
  observable_vector() noexcept(noexcept(Allocator()))
      : observable_vector(Allocator()) {}
  explicit observable_vector(const Allocator &alloc) noexcept : data(alloc) {}
  observable_vector(size_type count, const T &value,
                    const Allocator &alloc = Allocator())
      : data(count, value, alloc) {}
  explicit observable_vector(size_type count,
                             const Allocator &alloc = Allocator())
      : data(count, alloc) {}
  observable_vector(observable_vector &&other) noexcept : data(other.data) {}
  observable_vector(observable_vector &&other, const Allocator &alloc)
      : data(other.data, alloc) {}
  observable_vector(std::initializer_list<T> init,
                    const Allocator &alloc = Allocator())
      : data(init, alloc) {}
  template <class InputIt>
  observable_vector(InputIt first, InputIt last,
                    const Allocator &alloc = Allocator())
      : data(first, last, alloc) {}
  observable_vector &operator=(observable_vector const &other) {
    if (this != &other) {
      data = other.data;
      for (auto o : observers) {
        if (o != nullptr) {
          o->collection_changed(
              {collection_action::assign, std::vector<size_t>{}});
        }
      }
    }
    return *this;
  }
  observable_vector &operator=(observable_vector &&other) {
    if (this != &other) {
      data = std::move(other.data);
      for (auto o : observers) {
        if (o != nullptr) {
          o->collection_changed(
              {collection_action::assign, std::vector<size_t>{}});
        }
      }
    }
    return *this;
  }
  void push_back(T &&value) {
    data.push_back(value);
    for (auto o : observers) {
      if (o != nullptr) {
        o->collection_changed(
            {collection_action::add, std::vector<size_t>{data.size() - 1}});
      }
    }
  }
  void pop_back() {
    data.pop_back();
    for (auto o : observers) {
      if (o != nullptr) {
        o->collection_changed(
            {collection_action::remove, std::vector<size_t>{data.size() + 1}});
      }
    }
  }
  void clear() noexcept {
    data.clear();
    for (auto o : observers) {
      if (o != nullptr) {
        o->collection_changed(
            {collection_action::clear, std::vector<size_t>{}});
      }
    }
  }
  size_type size() const noexcept { return data.size(); }
  [[nodiscard]] bool empty() const noexcept { return data.empty(); }
  void add_observer(collection_observer *const o) { observers.push_back(o); }
  void remove_observer(collection_observer const *const o) {
    observers.erase(std::remove(std::begin(observers), std::end(observers), o),
                    std::end(observers));
  }
private:
  std::vector<T, Allocator> data;
  std::vector<collection_observer *> observers;
};
class observer : public collection_observer {
public:
  virtual void
  collection_changed(collection_change_notification notification) override {
    std::cout << "action: " << to_string(notification.action);
    if (!notification.item_indexes.empty()) {
      std::cout << ", indexes: ";
      for (auto i : notification.item_indexes)
        std::cout << i << ' ';
    }
    std::cout << std::endl;
  }
};
int main() {
  observable_vector<int> v;
  observer o;
  v.add_observer(&o);
  v.push_back(1);
  v.push_back(2);
  v.pop_back();
  v.clear();
  v.remove_observer(&o);
  v.push_back(3);
  v.push_back(4);
  v.add_observer(&o);
  observable_vector<int> v2{1, 2, 3};
  v = v2;
  v = observable_vector<int>{7, 8, 9};
}
```

### 72. Computing order price with discounts

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <cmath>
#include <assert.h>
inline bool are_equal(double const d1, double const d2,
                      double const diff = 0.001) {
  return std::abs(d1 - d2) <= diff;
}
struct discount_type {
  virtual double discount_percent(double const price,
                                  double const quantity) const noexcept = 0;
  virtual ~discount_type() {}
};
struct fixed_discount final : public discount_type {
  explicit fixed_discount(double const discount) noexcept
      : discount(discount) {}
  virtual double discount_percent(double const, double const) const noexcept {
    return discount;
  }
private:
  double discount;
};
struct volume_discount final : public discount_type {
  explicit volume_discount(double const quantity,
                           double const discount) noexcept
      : discount(discount), min_quantity(quantity) {}
  virtual double discount_percent(double const, double const quantity) const
      noexcept {
    return quantity >= min_quantity ? discount : 0;
  }
private:
  double discount;
  double min_quantity;
};
struct price_discount : public discount_type {
  explicit price_discount(double const price, double const discount) noexcept
      : discount(discount), min_total_price(price) {}
  virtual double discount_percent(double const price,
                                  double const quantity) const noexcept {
    return price * quantity >= min_total_price ? discount : 0;
  }
private:
  double discount;
  double min_total_price;
};
struct amount_discount : public discount_type {
  explicit amount_discount(double const price, double const discount) noexcept
      : discount(discount), min_total_price(price) {}
  virtual double discount_percent(double const price, double const) const
      noexcept {
    return price >= min_total_price ? discount : 0;
  }
private:
  double discount;
  double min_total_price;
};
struct customer {
  std::string name;
  discount_type *discount;
};
enum class article_unit { piece, kg, meter, sqmeter, cmeter, liter };
struct article {
  int id;
  std::string name;
  double price;
  article_unit unit;
  discount_type *discount;
};
struct order_line {
  article product;
  int quantity;
  discount_type *discount;
};
struct order {
  int id;
  customer *buyer;
  std::vector<order_line> lines;
  discount_type *discount;
};
struct price_calculator {
  virtual double calculate_price(order const &o) = 0;
};
struct cumulative_price_calculator : public price_calculator {
  virtual double calculate_price(order const &o) override {
    double price = 0;
    for (auto ol : o.lines) {
      double line_price = ol.product.price * ol.quantity;
      if (ol.product.discount != nullptr)
        line_price *= (1.0 - ol.product.discount->discount_percent(
                                 ol.product.price, ol.quantity));
      if (ol.discount != nullptr)
        line_price *= (1.0 - ol.discount->discount_percent(ol.product.price,
                                                           ol.quantity));
      if (o.buyer != nullptr && o.buyer->discount != nullptr)
        line_price *= (1.0 - o.buyer->discount->discount_percent(
                                 ol.product.price, ol.quantity));
      price += line_price;
    }
    if (o.discount != nullptr)
      price *= (1.0 - o.discount->discount_percent(price, 0));
    return price;
  }
};
int main() {
  fixed_discount d1(0.1);
  volume_discount d2(10, 0.15);
  price_discount d3(100, 0.05);
  amount_discount d4(100, 0.05);
  customer c1{"default", nullptr};
  customer c2{"john", &d1};
  customer c3{"joane", &d3};
  article a1{1, "pen", 5, article_unit::piece, nullptr};
  article a2{2, "expensive pen", 15, article_unit::piece, &d1};
  article a3{3, "scissors", 10, article_unit::piece, &d2};
  cumulative_price_calculator calc;
  order o1{101, &c1, {{a1, 1, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o1), 5));
  order o2{102, &c2, {{a1, 1, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o2), 4.5));
  order o3{103, &c1, {{a2, 1, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o3), 13.5));
  order o4{104, &c2, {{a2, 1, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o4), 12.15));
  order o5{105, &c1, {{a3, 1, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o5), 10));
  order o6{106, &c1, {{a3, 15, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o6), 127.5));
  order o7{107, &c3, {{a3, 15, nullptr}}, nullptr};
  assert(are_equal(calc.calculate_price(o7), 121.125));
  order o8{108, &c3, {{a2, 20, &d1}}, nullptr};
  assert(are_equal(calc.calculate_price(o8), 230.85));
  order o9{109, &c3, {{a2, 20, &d1}}, &d4};
  assert(are_equal(calc.calculate_price(o9), 219.3075));
}
```

## Data Serialization

### 73. Serializing and deserializing data to or from XML

```c++

#include <string>
#include <string_view>
#include <assert.h>
#include "pugixml.hpp"
#include "movies.h"
void serialize(movie_list const &movies, std::string_view filepath) {
  pugi::xml_document doc;
  auto root = doc.append_child("movies");
  for (auto const &m : movies) {
    auto movie_node = root.append_child("movie");
    movie_node.append_attribute("id").set_value(m.id);
    movie_node.append_attribute("title").set_value(m.title.c_str());
    movie_node.append_attribute("year").set_value(m.year);
    movie_node.append_attribute("length").set_value(m.length);
    auto cast_node = movie_node.append_child("cast");
    for (auto const &c : m.cast) {
      auto node = cast_node.append_child("role");
      node.append_attribute("star").set_value(c.actor.c_str());
      node.append_attribute("name").set_value(c.role.c_str());
    }
    auto directors_node = movie_node.append_child("directors");
    for (auto const &director : m.directors) {
      directors_node.append_child("director")
          .append_attribute("name")
          .set_value(director.c_str());
    }
    auto writers_node = movie_node.append_child("writers");
    for (auto const &writer : m.writers) {
      writers_node.append_child("writer").append_attribute("name").set_value(
          writer.c_str());
    }
  }
  doc.save_file(filepath.data());
}
movie_list deserialize(std::string_view filepath) {
  pugi::xml_document doc;
  movie_list movies;
  auto result = doc.load_file(filepath.data());
  if (result) {
    auto root = doc.child("movies");
    for (auto movie_node = root.child("movie"); movie_node;
         movie_node = movie_node.next_sibling("movie")) {
      movie m;
      m.id = movie_node.attribute("id").as_uint();
      m.title = movie_node.attribute("title").as_string();
      m.year = movie_node.attribute("year").as_uint();
      m.length = movie_node.attribute("length").as_uint();
      for (auto role_node : movie_node.child("cast").children("role")) {
        m.cast.push_back(casting_role{role_node.attribute("star").as_string(),
                                      role_node.attribute("name").as_string()});
      }
      for (auto director_node :
           movie_node.child("directors").children("director")) {
        m.directors.push_back(director_node.attribute("name").as_string());
      }
      for (auto writer_node : movie_node.child("writers").children("writer")) {
        m.writers.push_back(writer_node.attribute("name").as_string());
      }
      movies.push_back(m);
    }
  }
  return movies;
}
int main() {
  movie_list movies{{
                        11001,
                        "The Matrix",
                        1999,
                        196,
                        {{"Keanu Reeves", "Neo"},
                         {"Laurence Fishburne", "Morpheus"},
                         {"Carrie-Anne Moss", "Trinity"},
                         {"Hugo Weaving", "Agent Smith"}},
                        {"Lana Wachowski", "Lilly Wachowski"},
                        {"Lana Wachowski", "Lilly Wachowski"},
                    },
                    {
                        9871,
                        "Forrest Gump",
                        1994,
                        202,
                        {{"Tom Hanks", "Forrest Gump"},
                         {"Sally Field", "Mrs. Gump"},
                         {"Robin Wright", "Jenny Curran"},
                         {"Mykelti Williamson", "Bubba Blue"}},
                        {"Robert Zemeckis"},
                        {"Winston Groom", "Eric Roth"},
                    }};
  serialize(movies, "movies.xml");
  auto result = deserialize("movies.xml");
  assert(result.size() == 2);
  assert(result[0].title == "The Matrix");
  assert(result[1].title == "Forrest Gump");
}
```

### 74. Selecting data from XML using XPath

```c++

#include <iostream>
#include <string>
#include <string_view>
#include "pugixml.hpp"
int main() {
  std::string text = R"(
<?xml version="1.0"?>
<movies>
	<movie id="11001" title="The Matrix" year="1999" length="196">
		<cast>
			<role star="Keanu Reeves" name="Neo" />
			<role star="Laurence Fishburne" name="Morpheus" />
			<role star="Carrie-Anne Moss" name="Trinity" />
			<role star="Hugo Weaving" name="	Agent Smith" />
		</cast>
		<directors>
			<director name="Lana Wachowski" />
			<director name="Lilly Wachowski" />
		</directors>
		<writers>
			<writer name="Lana Wachowski" />
			<writer name="Lilly Wachowski" />
		</writers>
	</movie>
	<movie id="9871" title="Forrest Gump" year="1994" length="202">
		<cast>
			<role star="Tom Hanks" name="Forrest Gump" />
			<role star="Sally Field" name="Mrs. Gump" />
			<role star="Robin Wright" name="Jenny Curran" />
			<role star="Mykelti Williamson" name="Bubba Blue" />
		</cast>
		<directors>
			<director name="Robert Zemeckis" />
		</directors>
		<writers>
			<writer name="Winston Groom" />
			<writer name="Eric Roth" />
		</writers>
	</movie>
</movies>
)";
  pugi::xml_document doc;
  if (doc.load_string(text.c_str())) {
    try {
      auto titles = doc.select_nodes("/movies/movie[@year>1995]");
      for (auto it : titles) {
        std::cout << it.node().attribute("title").as_string() << std::endl;
      }
    } catch (pugi::xpath_exception const &e) {
      std::cout << e.result().description() << std::endl;
    }
    try {
      auto titles = doc.select_nodes("/movies/movie/cast/role[last()]");
      for (auto it : titles) {
        std::cout << it.node().attribute("star").as_string() << std::endl;
      }
    } catch (pugi::xpath_exception const &e) {
      std::cout << e.result().description() << std::endl;
    }
  }
}
```

### 75. Serializing data to JSON

```c++

#include <iostream>
#include <string_view>
#include <fstream>
#include "json.hpp"
#include "movies.h"
using json = nlohmann::json;
void to_json(json &j, casting_role const &c) {
  j = json{{"star", c.actor}, {"name", c.role}};
}
void to_json(json &j, movie const &m) {
  j = json::object({{"id", m.id},
                    {"title", m.title},
                    {"year", m.year},
                    {"length", m.length},
                    {"cast", m.cast},
                    {"directors", m.directors},
                    {"writers", m.writers}});
}
void serialize(movie_list const &movies, std::string_view filepath) {
  json jdata{{"movies", movies}};
  std::ofstream ofile(filepath.data());
  if (ofile.is_open()) {
    ofile << std::setw(2) << jdata << std::endl;
  }
}
int main() {
  movie_list movies{{
                        11001,
                        "The Matrix",
                        1999,
                        196,
                        {{"Keanu Reeves", "Neo"},
                         {"Laurence Fishburne", "Morpheus"},
                         {"Carrie-Anne Moss", "Trinity"},
                         {"Hugo Weaving", "Agent Smith"}},
                        {"Lana Wachowski", "Lilly Wachowski"},
                        {"Lana Wachowski", "Lilly Wachowski"},
                    },
                    {
                        9871,
                        "Forrest Gump",
                        1994,
                        202,
                        {{"Tom Hanks", "Forrest Gump"},
                         {"Sally Field", "Mrs. Gump"},
                         {"Robin Wright", "Jenny Curran"},
                         {"Mykelti Williamson", "Bubba Blue"}},
                        {"Robert Zemeckis"},
                        {"Winston Groom", "Eric Roth"},
                    }};
  serialize(movies, "movies.json");
}
```

### 76. Deserializing data from JSON

```c++

#include <iostream>
#include <string_view>
#include <fstream>
#include <assert.h>
#include "json.hpp"
#include "movies.h"
using json = nlohmann::json;
movie_list deserialize(std::string_view filepath) {
  movie_list movies;
  std::ifstream ifile(filepath.data());
  if (ifile.is_open()) {
    json jdata;
    try {
      ifile >> jdata;
      if (jdata.is_object()) {
        for (auto &element : jdata.at("movies")) {
          movie m;
          m.id = element.at("id").get<unsigned int>();
          m.title = element.at("title").get<std::string>();
          m.year = element.at("year").get<unsigned int>();
          m.length = element.at("length").get<unsigned int>();
          for (auto &role : element.at("cast")) {
            m.cast.push_back(casting_role{role.at("star").get<std::string>(),
                                          role.at("name").get<std::string>()});
          }
          for (auto &director : element.at("directors")) {
            m.directors.push_back(director);
          }
          for (auto &writer : element.at("writers")) {
            m.writers.push_back(writer);
          }
          movies.push_back(std::move(m));
        }
      }
    } catch (std::exception const &ex) {
      std::cout << ex.what() << std::endl;
    }
  }
  return movies;
}
int main() {
  auto movies = deserialize("movies.json");
  assert(movies.size() == 2);
  assert(movies[0].title == "The Matrix");
  assert(movies[1].title == "Forrest Gump");
}
```

### 77. Printing a list of movies to a PDF

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <iomanip>
#include "PDFWriter/PDFWriter.h"
#include "PDFWriter/PDFPage.h"
#include "PDFWriter/PageContentContext.h"
#include "PDFWriter/PDFUsedFont.h"
#include "movies.h"
#ifdef _WIN32
static const std::string fonts_dir = R"(c:\windows\fonts\)";
#elif defined(__APPLE__)
static const std::string fonts_dir = R"(/Library/Fonts/)";
#else
static const std::string fonts_dir = R"(/usr/share/fonts)";
#endif
void print_pdf(movie_list const &movies, std::string_view path) {
  const int height = 842;
  const int width = 595;
  const int left = 60;
  const int top = 770;
  const int right = 535;
  const int bottom = 60;
  const int line_height = 28;
  PDFWriter pdf;
  pdf.StartPDF(path.data(), ePDFVersion13);
  auto font = pdf.GetFontForFile(fonts_dir + "Arial.ttf");
  AbstractContentContext::GraphicOptions pathStrokeOptions(
      AbstractContentContext::eStroke, AbstractContentContext::eRGB, 0xff000000,
      1);
  PDFPage *page = nullptr;
  PageContentContext *context = nullptr;
  int index = 0;
  for (size_t i = 0; i < movies.size(); ++i) {
    index = i % 25;
    if (index == 0) {
      if (page != nullptr) {
        DoubleAndDoublePairList pathPoints;
        pathPoints.push_back(DoubleAndDoublePair(left, bottom));
        pathPoints.push_back(DoubleAndDoublePair(right, bottom));
        context->DrawPath(pathPoints, pathStrokeOptions);
        pdf.EndPageContentContext(context);
        pdf.WritePageAndRelease(page);
      }
      page = new PDFPage();
      page->SetMediaBox(PDFRectangle(0, 0, width, height));
      context = pdf.StartPageContentContext(page);
      {
        DoubleAndDoublePairList pathPoints;
        pathPoints.push_back(DoubleAndDoublePair(left, top));
        pathPoints.push_back(DoubleAndDoublePair(right, top));
        context->DrawPath(pathPoints, pathStrokeOptions);
      }
    }
    if (i == 0) {
      AbstractContentContext::TextOptions const textOptions(
          font, 26, AbstractContentContext::eGray, 0);
      context->WriteText(left, top + 15, "List of movies", textOptions);
    }
    auto textw = 0;
    {
      AbstractContentContext::TextOptions const textOptions(
          font, 20, AbstractContentContext::eGray, 0);
      context->WriteText(left, top - 20 - line_height * index, movies[i].title,
                         textOptions);
      auto textDimensions = font->CalculateTextDimensions(movies[i].title, 20);
      textw = textDimensions.width;
    }
    {
      AbstractContentContext::TextOptions const textOptions(
          font, 16, AbstractContentContext::eGray, 0);
      context->WriteText(left + textw + 5, top - 20 - line_height * index,
                         " (" + std::to_string(movies[i].year) + ")",
                         textOptions);
      std::stringstream s;
      s << movies[i].length / 60 << ':' << std::setw(2) << std::setfill('0')
        << movies[i].length % 60;
      context->WriteText(right - 30, top - 20 - line_height * index, s.str(),
                         textOptions);
    }
  }
  DoubleAndDoublePairList pathPoints;
  pathPoints.push_back(
      DoubleAndDoublePair(left, top - line_height * (index + 1)));
  pathPoints.push_back(
      DoubleAndDoublePair(right, top - line_height * (index + 1)));
  context->DrawPath(pathPoints, pathStrokeOptions);
  if (page != nullptr) {
    pdf.EndPageContentContext(context);
    pdf.WritePageAndRelease(page);
  }
  pdf.EndPDF();
}
int main() {
  movie_list movies{
      {1, "The Matrix", 1999, 136},
      {2, "Forrest Gump", 1994, 142},
      {3, "The Truman Show", 1998, 103},
      {4, "The Pursuit of Happyness", 2006, 117},
      {5, "Fight Club", 1999, 139},
      {6, "Inglourious Basterds", 2009, 153},
      {7, "The Dark Knight Rises", 2012, 164},
      {8, "The Dark Knight", 2008, 152},
      {9, "Pulp Fiction", 1994, 154},
      {10, "Inception", 2010, 148},
      {11, "The Shawshank Redemption", 1994, 142},
      {12, "The Silence of the Lambs", 1991, 118},
      {13, "Philadelphia", 1993, 125},
      {14, "One Flew Over the Cuckoo's Nest", 1975, 80},
      {15, "Memento", 2000, 113},
      {16, "Trainspotting", 1996, 94},
      {17, "Fargo", 1998, 98},
      {18, "Reservoir Dogs", 1992, 99},
      {19, "The Departed", 2006, 151},
      {20, "Se7en", 1995, 127},
      {21, "American History X", 1998, 119},
      {22, "Silver Linings Playbook", 2012, 122},
      {23, "2001: A Space Odyssey", 1968, 149},
      {24, "Monty Python and the Holy Grail", 1975, 91},
      {25, "Life of Brian", 1979, 94},
      {26, "Children of Men", 2006, 109},
      {27, "Sin City", 2005, 124},
      {28, "L.A. Confidential", 1997, 138},
      {29, "Shutter Island", 2010, 138},
  };
  print_pdf(movies, "movies.pdf");
}
```

### 78. Creating a PDF from a collection of images

```c++

#include <iostream>
#include <string_view>
#include "PDFWriter/PDFWriter.h"
#include "PDFWriter/PDFPage.h"
#include "PDFWriter/PageContentContext.h"
#include "PDFWriter/PDFFormXObject.h"
#ifdef USE_BOOST_FILESYSTEM
#include <boost/filesystem/path.hpp>
#include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#include <filesystem>
#ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#else
namespace fs = std::filesystem;
#endif
#endif
std::vector<std::string> get_images(fs::path const &dirpath) {
  std::vector<std::string> paths;
  for (auto const &p : fs::directory_iterator(dirpath)) {
    if (p.path().extension() == ".jpg")
      paths.push_back(p.path().string());
  }
  return paths;
}
void print_pdf(fs::path const &pdfpath, fs::path const &dirpath) {
  const int height = 842;
  const int width = 595;
  const int margin = 20;
  auto image_paths = get_images(dirpath);
  PDFWriter pdf;
  pdf.StartPDF(pdfpath.string(), ePDFVersion13);
  PDFPage *page = nullptr;
  PageContentContext *context = nullptr;
  auto top = height - margin;
  for (size_t i = 0; i < image_paths.size(); ++i) {
    auto dims = pdf.GetImageDimensions(image_paths[i]);
    if (i == 0 || top - dims.second < margin) {
      if (page != nullptr) {
        pdf.EndPageContentContext(context);
        pdf.WritePageAndRelease(page);
      }
      page = new PDFPage();
      page->SetMediaBox(PDFRectangle(0, 0, width, height));
      context = pdf.StartPageContentContext(page);
      top = height - margin;
    }
    context->DrawImage(margin, top - dims.second, image_paths[i]);
    top -= dims.second + margin;
  }
  if (page != nullptr) {
    pdf.EndPageContentContext(context);
    pdf.WritePageAndRelease(page);
  }
  pdf.EndPDF();
}
int main() { print_pdf("sample.pdf", "res"); }
```

## Archives, Images, and Databases

### 79. Finding files in a ZIP archive

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <regex>
#include "ZipFile.h"
#include "ZipArchive.h"
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
std::vector<std::string> find_in_archive(
   fs::path const & archivepath,
   std::string_view pattern)
{
   std::vector<std::string> results;
   if (fs::exists(archivepath))
   {
      try
      {
         auto archive = ZipFile::Open(archivepath.string());
         for (size_t i = 0; i < archive->GetEntriesCount(); ++i)
         {
            auto entry = archive->GetEntry(i);
            if (entry)
            {
               if (!entry->IsDirectory())
               {
                  auto name = entry->GetName();
                  if (std::regex_match(name, std::regex{ pattern.data() }))
                  {
                     results.push_back(entry->GetFullName());
                  }
               }
            }
         }
      }
      catch (std::exception const & ex)
      {
         std::cout << ex.what() << std::endl;
      }
   }
   return results;
}
int main()
{
   std::string archivepath;
   std::cout << "Archive path:";
   std::cin >> archivepath;
   std::string pattern;
   std::cout << "Pattern:";
   std::cin >> pattern;
   std::cout << "Results:" << std::endl;
   for (auto const & name : find_in_archive(archivepath, pattern))
   {
      std::cout << name << std::endl;
   }
}
```

### 80. Compressing and decompressing files to or from a ZIP archive

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <fstream>
#include "ZipFile.h"
#include "utils/stream_utils.h"
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
void compress(
   fs::path const & source,
   fs::path const & archive,
   std::function<void(std::string_view)> reporter)
{
   if (fs::is_regular_file(source))
   {
      if (reporter) reporter("Compressing " + source.string());
      ZipFile::AddFile(archive.string(), source.string(), LzmaMethod::Create());
   }
   else
   {
      for (auto const & p : fs::recursive_directory_iterator(source))
      {
         if (reporter) reporter("Compressing " + p.path().string());
         if (fs::is_directory(p))
         {
            auto zipArchive = ZipFile::Open(archive.string());
            auto entry = zipArchive->CreateEntry(p.path().string());
            entry->SetAttributes(ZipArchiveEntry::Attributes::Directory);
            ZipFile::SaveAndClose(zipArchive, archive.string());
         }
         else if (fs::is_regular_file(p))
         {
            ZipFile::AddFile(archive.string(), p.path().string(), LzmaMethod::Create());
         }
      }
   }
}
void ensure_directory_exists(fs::path const & dir)
{
   if (!fs::exists(dir))
   {
#ifdef USE_BOOST_FILESYSTEM
      boost::system::error_code err;
#else
      std::error_code err;
#endif
      fs::create_directories(dir, err);
   }
}
void decompress(
   fs::path const & destination,
   fs::path const & archive,
   std::function<void(std::string_view)> reporter)
{
   ensure_directory_exists(destination);
   auto zipArchive = ZipFile::Open(archive.string());
   for (size_t i = 0; i < zipArchive->GetEntriesCount(); ++i)
   {
      auto entry = zipArchive->GetEntry(i);
      if (entry)
      {
         auto filepath = destination / fs::path{ entry->GetFullName() }.relative_path();
         if (reporter) reporter("Creating " + filepath.string());
         if (entry->IsDirectory())
         {
            ensure_directory_exists(filepath);
         }
         else
         {
            ensure_directory_exists(filepath.parent_path());
            std::ofstream destFile;
            destFile.open(
               filepath.string().c_str(),
               std::ios::binary | std::ios::trunc);
            if (!destFile.is_open())
            {
               if (reporter)
                  reporter("Cannot create destination file!");
            }
            auto dataStream = entry->GetDecompressionStream();
            if (dataStream)
            {
               utils::stream::copy(*dataStream, destFile);
            }
         }
      }
   }
}
int main()
{
   char option = 0;
   std::cout << "Select [c]ompress/[d]ecompress?";
   std::cin >> option;
   if (option == 'c')
   {
      std::string archivepath;
      std::string inputpath;
      std::cout << "Enter file or dir to compress:";
      std::cin >> inputpath;
      std::cout << "Enter archive path:";
      std::cin >> archivepath;
      compress(inputpath, archivepath, [](std::string_view message) {std::cout << message << std::endl; });
   }
   else if (option == 'd')
   {
      std::string archivepath;
      std::string outputpath;
      std::cout << "Enter dir to decompress:";
      std::cin >> outputpath;
      std::cout << "Enter archive path:";
      std::cin >> archivepath;
      decompress(outputpath, archivepath, [](std::string_view message) {std::cout << message << std::endl; });
   }
   else
   {
      std::cout << "invalid option" << std::endl;
   }
}
```

### 81. Compressing and decompressing files to or from a ZIP archive with a password

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <fstream>
#include "ZipFile.h"
#include "utils/stream_utils.h"
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
void compress(
   fs::path const & source,
   fs::path const & archive,
   std::string_view password,
   std::function<void(std::string_view)> reporter)
{
   if (fs::is_regular_file(source))
   {
      if (reporter) reporter("Compressing " + source.string());
      ZipFile::AddEncryptedFile(
         archive.string(),
         source.string(),
         source.filename().string(),
         password.data(),
         LzmaMethod::Create());
   }
   else
   {
      for (auto const & p : fs::recursive_directory_iterator(source))
      {
         if (reporter) reporter("Compressing " + p.path().string());
         if (fs::is_directory(p))
         {
            auto zipArchive = ZipFile::Open(archive.string());
            auto entry = zipArchive->CreateEntry(p.path().string());
            entry->SetAttributes(ZipArchiveEntry::Attributes::Directory);
            ZipFile::SaveAndClose(zipArchive, archive.string());
         }
         else if (fs::is_regular_file(p))
         {
            ZipFile::AddEncryptedFile(
               archive.string(),
               p.path().string(),
               p.path().filename().string(),
               password.data(),
               LzmaMethod::Create());
         }
      }
   }
}
void ensure_directory_exists(fs::path const & dir)
{
   if (!fs::exists(dir))
   {
#ifdef USE_BOOST_FILESYSTEM
      boost::system::error_code err;
#else
      std::error_code err;
#endif
      fs::create_directories(dir, err);
   }
}
void decompress(
   fs::path const & destination,
   fs::path const & archive,
   std::string_view password,
   std::function<void(std::string_view)> reporter)
{
   ensure_directory_exists(destination);
   auto zipArchive = ZipFile::Open(archive.string());
   for (size_t i = 0; i < zipArchive->GetEntriesCount(); ++i)
   {
      auto entry = zipArchive->GetEntry(i);
      if (entry)
      {
         auto filepath = destination / fs::path{ entry->GetFullName() }.relative_path();
         if (reporter) reporter("Creating " + filepath.string());
         if (entry->IsPasswordProtected())
            entry->SetPassword(password.data());
         if (entry->IsDirectory())
         {
            ensure_directory_exists(filepath);
         }
         else
         {
            ensure_directory_exists(filepath.parent_path());
            std::ofstream destFile;
            destFile.open(
               filepath.string().c_str(),
               std::ios::binary | std::ios::trunc);
            if (!destFile.is_open())
            {
               if (reporter)
                  reporter("Cannot create destination file!");
            }
            auto dataStream = entry->GetDecompressionStream();
            if (dataStream)
            {
               utils::stream::copy(*dataStream, destFile);
            }
         }
      }
   }
}
int main()
{
   char option = 0;
   std::cout << "Select [c]ompress/[d]ecompress?";
   std::cin >> option;
   if (option == 'c')
   {
      std::string archivepath;
      std::string inputpath;
      std::string password;
      std::cout << "Enter file or dir to compress:";
      std::cin >> inputpath;
      std::cout << "Enter archive path:";
      std::cin >> archivepath;
      std::cout << "Enter password:";
      std::cin >> password;
      compress(inputpath, archivepath, password, [](std::string_view message) {std::cout << message << std::endl; });
   }
   else if (option == 'd')
   {
      std::string archivepath;
      std::string outputpath;
      std::string password;
      std::cout << "Enter dir to decompress:";
      std::cin >> outputpath;
      std::cout << "Enter archive path:";
      std::cin >> archivepath;
      std::cout << "Enter password:";
      std::cin >> password;
      decompress(outputpath, archivepath, password, [](std::string_view message) {std::cout << message << std::endl; });
   }
   else
   {
      std::cout << "invalid option" << std::endl;
   }
}
```

### 82. Creating a PNG that represents a national flag

```c++

#include <iostream>
#include <string_view>
#include <string>
#include "pngwriter.h"
void create_flag(int const width, int const height, std::string_view filepath)
{
   pngwriter flag{ width, height, 0, filepath.data() };
   int const size = width / 3;
   // red rectangle
   flag.filledsquare(0, 0, size, 2 * size, 65535, 0, 0);
   // yellow rectangle
   flag.filledsquare(size, 0, 2 * size, 2 * size, 65535, 65535, 0);
   // blue rectangle
   flag.filledsquare(2 * size, 0, 3 * size, 2 * size, 0, 0, 65535);
   flag.close();
}
int main()
{
   int width = 0, height = 0;
   std::string filepath;
   std::cout << "Width: "; 
   std::cin >> width;
   std::cout << "Heigh: ";
   std::cin >> height;
   std::cout << "Output: ";
   std::cin >> filepath;
   create_flag(width, height, filepath);
}
```

### 83. Creating verification text PNG images

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <random>
#include <array>
#include "pngwriter.h"
void create_image(
   int const width, int const height, 
   std::string_view font, int const font_size,
   std::string_view filepath)
{
   pngwriter image{ width, height, 0, filepath.data() };
   std::random_device rd;
   std::mt19937 mt;
   auto seed_data = std::array<int, std::mt19937::state_size> {};
   std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
   std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
   mt.seed(seq);
   std::uniform_int_distribution<> udx(0, width);
   std::uniform_int_distribution<> udy(0, height);
   std::uniform_int_distribution<> udc(0, 65535);
   std::uniform_int_distribution<> udt(0, 25);
   // gradient background
   for (int iter = 0; iter <= width; iter++)
   {
      image.line(
         iter, 0, iter, height,
         65535 - int(65535 * ((double)iter) / (width)),
         int(65535 * ((double)iter) / (width)),
         65535);
   }
   // random text
   std::string font_family = font.data();
   for (int i = 0; i < 6; ++i)
   {
      image.plot_text(
         // font
         font_family.data(), font_size,
         // position
         i*width / 6 + 10, height / 2 - 10,
         // angle
         (i % 2 == 0 ? -1 : 1)*(udt(mt) * 3.14) / 180,
         // text
         std::string(1, char('A' + udt(mt))).data(),
         // color
         0, 0, 0);
   }
   // random lines
   for (int i = 0; i < 4; ++i)
   {
      image.line(udx(mt), 0, udx(mt), height,
         udc(mt), udc(mt), udc(mt));
      image.line(0, udy(mt), width, udy(mt),
         udc(mt), udc(mt), udc(mt));
   }
   image.close();
}
int main()
{
   std::string font_path;
#ifdef _WIN32
      font_path = R"(c:\windows\fonts\arial.ttf)";
#elif defined (__APPLE__)
      font_path = R"(/Library/Fonts/Arial.ttf)";
#else
   std::cout << "Font path: ";
   std::cin >> font_path;
#endif
   create_image(200, 50, 
                font_path, 18,
                "validation.png");
}
```

### 84. EAN-13 barcode generator

```c++

#include <iostream>
#include <string_view>
#include <array>
#include <algorithm>
#include <numeric>
#include <bitset>
#include <assert.h>
#include "pngwriter.h"
struct ean13
{
public:
   ean13(std::string_view code)
   {
      if (code.length() == 13)
      {
         if (code[12] != '0' + get_crc(code.substr(0,12)))
            throw std::runtime_error("Not an EAN-13 format.");
         number = code;
      }
      else if (code.length() == 12)
      {
         number = code.data() + std::string(1, '0' + get_crc(code));
      }
   }
   ean13(unsigned long long code)
      :ean13(std::to_string(code))
   {
   }
   std::array<unsigned char, 13> to_array() const
   {
      std::array<unsigned char, 13> result;
      for (int i = 0; i < 13; ++i)
         result[i] = static_cast<unsigned char>(number[i] - '0');
      return result;
   }

   std::string to_string() const noexcept
   {
      return number;
   }
private:
   unsigned char get_crc(std::string_view code)
   {
      unsigned char weights[12] = { 1,3,1,3,1,3,1,3,1,3,1,3 };
      size_t index = 0;
      auto sum = std::accumulate(
         std::begin(code), std::end(code), 0,
         [&weights, &index](int const total, char const c) {
         return total + weights[index++] * (c - '0'); });
      return 10 - sum % 10;
   }
   std::string number;
};
struct ean13_barcode_generator
{
   void create(ean13 const & code,
      std::string_view filename,
      int const digit_width = 3,
      int const height = 50,
      int const margin = 10)
   {
      pngwriter image(
         margin * 2 + 95 * digit_width,
         height + margin * 2,
         65535,
         filename.data());
      std::array<unsigned char, 13> digits = code.to_array();
      int x = margin;
      x = draw_digit(marker_start, 3, image, x, margin, digit_width, height);
      for (int i = 0; i < 6; ++i)
      {
         int code = encodings[digits[1 + i]][eandigits[digits[0]][i]];
         x = draw_digit(code, 7, image, x, margin, digit_width, height);
      }
      x = draw_digit(marker_center, 5, image, x, margin, digit_width, height);
      for (int i = 0; i < 6; ++i)
      {
         int code = encodings[digits[7 + i]][2];
         x = draw_digit(code, 7, image, x, margin, digit_width, height);
      }
      x = draw_digit(marker_end, 3, image, x, margin, digit_width, height);
      image.close();
   }
private:
   int draw_digit(
      unsigned char code, unsigned int size,
      pngwriter& image,
      int const x, int const y,
      int const digit_width, int const height)
   {
      std::bitset<7> bits(code);
      int pos = x;
      for (int i = size - 1; i >= 0; --i)
      {
         if (bits[i])
         {
            image.filledsquare(pos, y, pos + digit_width, y + height, 0, 0, 0);
         }
         pos += digit_width;
      }
      return pos;
   }
   unsigned char encodings[10][3] =
   {
      { 0b0001101, 0b0100111, 0b1110010 },
      { 0b0011001, 0b0110011, 0b1100110 },
      { 0b0010011, 0b0011011, 0b1101100 },
      { 0b0111101, 0b0100001, 0b1000010 },
      { 0b0100011, 0b0011101, 0b1011100 },
      { 0b0110001, 0b0111001, 0b1001110 },
      { 0b0101111, 0b0000101, 0b1010000 },
      { 0b0111011, 0b0010001, 0b1000100 },
      { 0b0110111, 0b0001001, 0b1001000 },
      { 0b0001011, 0b0010111, 0b1110100 },
   };
   unsigned char eandigits[10][6] =
   {
      { 0,0,0,0,0,0 },
      { 0,0,1,0,1,1 },
      { 0,0,1,1,0,1 },
      { 0,0,1,1,1,0 },
      { 0,1,0,0,1,1 },
      { 0,1,1,0,0,1 },
      { 0,1,1,1,0,0 },
      { 0,1,0,1,0,1 },
      { 0,1,0,1,1,0 },
      { 0,1,1,0,1,0 },
   };
   unsigned char marker_start = 0b101;
   unsigned char marker_end = 0b101;
   unsigned char marker_center = 0b01010;
};
int main()
{
   assert("4006381333931" == ean13("400638133393").to_string());
   assert("0012345678905" == ean13("001234567890").to_string());
   assert("0012345678905" == ean13("001234567890").to_string());
   assert("8711253001202" == ean13("8711253001202").to_string());
   assert("5901234123457" == ean13("5901234123457").to_string());
   ean13_barcode_generator generator;
   generator.create(
      ean13("8711253001202"), 
      "8711253001202.png", 
      5, 150, 30);
   generator.create(
      ean13("5901234123457"),
      "5901234123457.png",
      5, 150, 30);
}
```

### 85. Reading movies from an SQLite database

```c++

#include <iostream>
#include <vector>
#include "sqlite3.h"
#include "sqlite_modern_cpp.h"
#include "movies.h"
void print_movie(movie const & m)
{
   std::cout << "[" << m.id << "] "
      << m.title << " (" << m.year << ") "
      << m.length << "min" << std::endl;
   std::cout << " directed by: ";
   for (auto const & d : m.directors) std::cout << d << ",";
   std::cout << std::endl;
   std::cout << " written by: ";
   for (auto const & w : m.writers) std::cout << w << ",";
   std::cout << std::endl;
   std::cout << " cast: ";
   for (auto const & r : m.cast) std::cout << r.actor << " (" << r.role << "),";
   std::cout << std::endl << std::endl;
}
std::vector<std::string> get_directors(sqlite3_int64 const movie_id, 
                                       sqlite::database & db)
{
   std::vector<std::string> result;
   db << R"(select p.name from directors as d 
            join persons as p on d.personid = p.rowid 
            where d.movieid = ?;)"
      << movie_id
      >> [&result](std::string const name)
   {
      result.emplace_back(name);
   };
   return result;
}
std::vector<std::string> get_writers(sqlite3_int64 const movie_id, 
                                     sqlite::database & db)
{
   std::vector<std::string> result;
   db << R"(select p.name from writers as w
         join persons as p on w.personid = p.rowid 
         where w.movieid = ?;)"
      << movie_id
      >> [&result](std::string const name)
   {
      result.emplace_back(name);
   };
   return result;
}
std::vector<casting_role> get_cast(sqlite3_int64 const movie_id, 
                                   sqlite::database & db)
{
   std::vector<casting_role> result;
   db << R"(select p.name, c.role from casting as c
         join persons as p on c.personid = p.rowid
         where c.movieid = ?;)"
      << movie_id
      >> [&result](std::string const name, std::string role)
   {
      result.emplace_back(casting_role{ name, role });
   };
   return result;
}
movie_list get_movies(sqlite::database & db)
{
   movie_list movies;
   db << R"(select rowid, * from movies;)"
      >> [&movies, &db](sqlite3_int64 const rowid, std::string const & title, 
                        int const year, int const length)
   {
      movies.emplace_back(movie{
         static_cast<unsigned int>(rowid),
         title,
         year,
         static_cast<unsigned int>(length),
         get_cast(rowid, db),
         get_directors(rowid, db),
         get_directors(rowid, db)
         });
   };
   return movies;
}
int main()
{
   try
   {
      sqlite::database db(R"(cppchallenger85.db)");
      auto movies = get_movies(db);
      for (auto const & m : movies)
         print_movie(m);
   }
   catch (sqlite::sqlite_exception const & e)
   {
      std::cerr << e.get_code() << ": " << e.what() << " during "
                << e.get_sql() << std::endl;
   }
   catch (std::exception const & e)
   {
      std::cerr << e.what() << std::endl;
   }
}
```

### 86. Inserting movies into an SQLite database transactionally

```c++

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include "sqlite3.h"
#include "sqlite_modern_cpp.h"
#include "movies.h"
std::vector<std::string> split(std::string text, char const delimiter)
{
   auto sstr = std::stringstream{ text };
   auto tokens = std::vector<std::string>{};
   auto token = std::string{};
   while (std::getline(sstr, token, delimiter))
   {
      if (!token.empty()) tokens.push_back(token);
   }
   return tokens;
}
void print_movie(movie const & m)
{
   std::cout << "[" << m.id << "] "
      << m.title << " (" << m.year << ") "
      << m.length << "min" << std::endl;
   std::cout << " directed by: ";
   for (auto const & d : m.directors) std::cout << d << ",";
   std::cout << std::endl;
   std::cout << " written by: ";
   for (auto const & w : m.writers) std::cout << w << ",";
   std::cout << std::endl;
   std::cout << " cast: ";
   for (auto const & r : m.cast) std::cout << r.actor << " (" << r.role << "),";
   std::cout << std::endl << std::endl;
}
movie read_movie()
{
   movie m;
   std::cout << "Enter movie" << std::endl;
   std::cout << "Title: ";
   std::getline(std::cin, m.title);
   std::cout << "Year: "; std::cin >> m.year;
   std::cout << "Length: "; std::cin >> m.length;
   std::cin.ignore();
   std::string directors;
   std::cout << "Directors: ";
   std::getline(std::cin, directors);
   m.directors = split(directors, ',');
   std::string writers;
   std::cout << "Writers: ";
   std::getline(std::cin, writers);
   m.writers = split(writers, ',');
   std::string cast;
   std::cout << "Cast: ";
   std::getline(std::cin, cast);
   auto roles = split(cast, ',');
   for (auto const & r : roles)
   {
      auto pos = r.find_first_of('=');
      casting_role cr;
      cr.actor = r.substr(0, pos);
      cr.role = r.substr(pos + 1, r.size() - pos - 1);
      m.cast.push_back(cr);
   }
   return m;
}
std::vector<std::string> get_directors(sqlite3_int64 const movie_id, 
                                       sqlite::database & db)
{
   std::vector<std::string> result;
   db << R"(select p.name from directors as d 
            join persons as p on d.personid = p.rowid 
            where d.movieid = ?;)"
      << movie_id
      >> [&result](std::string const name)
   {
      result.emplace_back(name);
   };
   return result;
}
std::vector<std::string> get_writers(sqlite3_int64 const movie_id, 
                                     sqlite::database & db)
{
   std::vector<std::string> result;
   db << R"(select p.name from writers as w
         join persons as p on w.personid = p.rowid 
         where w.movieid = ?;)"
      << movie_id
      >> [&result](std::string const name)
   {
      result.emplace_back(name);
   };
   return result;
}
std::vector<casting_role> get_cast(sqlite3_int64 const movie_id, 
                                   sqlite::database & db)
{
   std::vector<casting_role> result;
   db << R"(select p.name, c.role from casting as c
         join persons as p on c.personid = p.rowid
         where c.movieid = ?;)"
      << movie_id
      >> [&result](std::string const name, std::string role)
   {
      result.emplace_back(casting_role{ name, role });
   };
   return result;
}
movie_list get_movies(sqlite::database & db)
{
   movie_list movies;
   db << R"(select rowid, * from movies;)"
      >> [&movies, &db](sqlite3_int64 const rowid, std::string const & title, 
                        int const year, int const length)
   {
      movies.emplace_back(movie{
         static_cast<unsigned int>(rowid),
         title,
         year,
         static_cast<unsigned int>(length),
         get_cast(rowid, db),
         get_directors(rowid, db),
         get_directors(rowid, db)
         });
   };
   return movies;
}
sqlite_int64 get_person_id(std::string const & name, sqlite::database & db)
{
   sqlite_int64 id = 0;

   db << "select rowid from persons where name=?;"
      << name
      >> [&id](sqlite_int64 const rowid) {id = rowid; };
   return id;
}
sqlite_int64 insert_person(std::string_view name, sqlite::database & db)
{
   db << "insert into persons values(?);"
      << name.data();
   return db.last_insert_rowid();
}
void insert_directors(sqlite_int64 const movie_id, 
                      std::vector<std::string> const & directors,
                      sqlite::database & db)
{
   for (auto const & director : directors)
   {
      auto id = get_person_id(director, db);
      if (id == 0)
         id = insert_person(director, db);
      db << "insert into directors values(?, ?);"
         << movie_id
         << id;
   }
}
void insert_writers(sqlite_int64 const movie_id, 
                    std::vector<std::string> const & writers,
                    sqlite::database & db)
{
   for (auto const & writer : writers)
   {
      auto id = get_person_id(writer, db);
      if (id == 0)
         id = insert_person(writer, db);
      db << "insert into writers values(?, ?);"
         << movie_id
         << id;
   }
}
void insert_cast(sqlite_int64 const movie_id, 
                 std::vector<casting_role> const & cast,
                 sqlite::database & db)
{
   for (auto const & cr : cast)
   {
      auto id = get_person_id(cr.actor, db);
      if (id == 0)
         id = insert_person(cr.actor, db);
      db << "insert into casting values(?,?,?);"
         << movie_id
         << id
         << cr.role;
   }
}
void insert_movie(movie& m, sqlite::database & db)
{
   try
   {
      db << "begin;";
      db << "insert into movies values(?,?,?);"
         << m.title
         << m.year
         << m.length;
      auto movieid = db.last_insert_rowid();
      insert_directors(movieid, m.directors, db);
      insert_writers(movieid, m.writers, db);
      insert_cast(movieid, m.cast, db);
      m.id = static_cast<unsigned int>(movieid);
      db << "commit;";
   }
   catch (std::exception const &)
   {
      db << "rollback;";
   }
}
int main()
{
   try
   {
      sqlite::database db(R"(cppchallenger86.db)");
      auto movie = read_movie();
      insert_movie(movie, db);
      auto movies = get_movies(db);
      for (auto const & m : movies)
         print_movie(m);
   }
   catch (sqlite::sqlite_exception const & e)
   {
      std::cerr << e.get_code() << ": " << e.what() << " during "
                << e.get_sql() << std::endl;
   }
   catch (std::exception const & e)
   {
      std::cerr << e.what() << std::endl;
   }
}
```

### 87. Handling movie images in an SQLite database

```c++

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
#ifdef USE_BOOST_OPTIONAL
#  include <boost/optional.hpp>
using boost::optional;
#else
#  include <optional>
using std::optional;
#endif
#include "sqlite3.h"
#define MODERN_SQLITE_STD_OPTIONAL_SUPPORT
#include "sqlite_modern_cpp.h"
#include "movies.h"
movie_list get_movies(std::string_view title, sqlite::database & db)
{
   movie_list movies;
   db << R"(select rowid, * from movies where title=?;)"
      << title.data()
      >> [&movies, &db](sqlite3_int64 const rowid, std::string const & title,
         int const year, int const length)
   {
      movies.emplace_back(movie{
         static_cast<unsigned int>(rowid),
         title,
         year,
         static_cast<unsigned int>(length),
         {},
         {},
         {}
         });
   };
   return movies;
}
bool add_media(sqlite_int64 const movieid,
               std::string_view name,
               std::string_view description,
               std::vector<char> content,
               sqlite::database & db)
{
   try
   {
      db << "insert into media values(?,?,?,?)"
         << movieid
         << name.data()
         << description.data()
         << content;

      return true;
   }
   catch (...) { return false; }
}
media_list get_media(sqlite_int64 const movieid,
                     sqlite::database & db)
{
   media_list list;
   db << "select rowid, * from media where movieid = ?;"
      << movieid
      >> [&list](sqlite_int64 const rowid, 
            sqlite_int64 const movieid, 
            std::string const & name,
#ifdef USE_BOOST_OPTIONAL
            std::unique_ptr<std::string> const text,
#else
            optional<std::string> const text,
#endif
            std::vector<char> const & blob
         )
         {
      list.emplace_back(media{
         static_cast<unsigned int>(rowid),
         static_cast<unsigned int>(movieid),
         name,
#ifdef USE_BOOST_OPTIONAL
               text != nullptr ? *text : optional<std::string>{},
#else
               text,
#endif
               blob});
         };
   return list;
}
bool delete_media(sqlite_int64 const mediaid,
                  sqlite::database & db)
{
   try
   {
      db << "delete from media where rowid = ?;"
         << mediaid;
      return true;
   }
   catch (...) { return false; }
}
std::vector<std::string> split(std::string text, char const delimiter)
{
   auto sstr = std::stringstream{ text };
   auto tokens = std::vector<std::string>{};
   auto token = std::string{};
   while (std::getline(sstr, token, delimiter))
   {
      if (!token.empty()) tokens.push_back(token);
   }
   return tokens;
}
inline bool starts_with(std::string_view text, std::string_view part)
{
   return text.find(part) == 0;
}
inline std::string trim(std::string_view text)
{
   auto first{ text.find_first_not_of(' ') };
   auto last{ text.find_last_not_of(' ') };
   return text.substr(first, (last - first + 1)).data();
}
std::vector<char> load_image(std::string_view filepath)
{
   std::vector<char> data;
   std::ifstream ifile(filepath.data(), std::ios::binary | std::ios::ate);
   if (ifile.is_open())
   {
      auto size = ifile.tellg();
      ifile.seekg(0, std::ios::beg);
      data.resize(static_cast<size_t>(size));
      ifile.read(reinterpret_cast<char*>(data.data()), size);
   }
   return data;
}
void run_find(std::string_view line, sqlite::database & db)
{
   auto title = trim(line.substr(5));
   auto movies = get_movies(title, db);
   if(movies.empty())
      std::cout << "empty" << std::endl;      
   else
   {
      for (auto const m : movies)
      {
         std::cout
            << m.id << " | "
            << m.title << " | "
            << m.year << " | "
            << m.length << "min"
            << std::endl;
      }
   }      
}
void run_list(std::string_view line, sqlite::database & db)
{
   auto movieid = std::stoi(trim(line.substr(5)));
   if (movieid > 0)
   {
      auto list = get_media(movieid, db);
      if (list.empty())
      {
         std::cout << "empty" << std::endl;
      }
      else
      {
         for (auto const & m : list)
         {
            std::cout
               << m.id << " | "
               << m.movie_id << " | "
               << m.name << " | "
               << m.text.value_or("(null)") << " | "
               << m.blob.size() << " bytes"
               << std::endl;
         }
      }
   }
   else
      std::cout << "input error" << std::endl;
}
void run_add(std::string_view line, sqlite::database & db)
{
   auto parts = split(trim(line.substr(4)), ',');
   if (parts.size() == 3)
   {
      auto movieid = std::stoi(parts[0]);
      auto path = fs::path{parts[1]};
      auto desc = parts[2];
      auto content = load_image(parts[1]);
      auto name = path.filename().string();
      auto success = add_media(movieid, name, desc, content, db);
      if (success)
         std::cout << "added" << std::endl;
      else
         std::cout << "failed" << std::endl;
   }
   else
      std::cout << "input error" << std::endl;
}
void run_del(std::string_view line, sqlite::database & db)
{
   auto mediaid = std::stoi(trim(line.substr(4)));
   if (mediaid > 0)
   {
      auto success = delete_media(mediaid, db);
      if (success)
         std::cout << "deleted" << std::endl;
      else
         std::cout << "failed" << std::endl;
   }
   else
      std::cout << "input error" << std::endl;
}
void print_commands()
{
   std::cout
      << "find <title>                        finds a movie ID\n"
      << "list <movieid>                      lists the images of a movie\n"
      << "add <movieid>,<path>,<description>  adds a new image\n"
      << "del <imageid>                       delete an image\n"
      << "help                                shows available commands\n"
      << "exit                                exists the application\n";
}
int main()
{
   try
   {
      sqlite::database db(R"(cppchallenger87.db)");
      while (true)
      {
         std::string line;
         std::getline(std::cin, line);
         if (line == "help") print_commands();
         else if (line == "exit") break;
         else
         {
            if (starts_with(line, "find"))
               run_find(line, db);
            else if (starts_with(line, "list"))
               run_list(line, db);
            else if (starts_with(line, "add"))
               run_add(line, db);
            else if (starts_with(line, "del"))
               run_del(line, db);
            else
               std::cout << "unknown command" << std::endl;
         }
         std::cout << std::endl;
      }
   }
   catch (sqlite::sqlite_exception const & e)
   {
      std::cerr << e.get_code() << ": " << e.what() << " during "
                << e.get_sql() << std::endl;
   }
   catch (std::exception const & e)
   {
      std::cerr << e.what() << std::endl;
   }
}
```

## Cryptography

### 88. Caesar cipher

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <assert.h>
std::string caesar_encrypt(std::string_view text, int const shift)
{
   std::string str;
   str.reserve(text.length());
   for (auto const & c : text)
   {
      if (isalpha(c) && isupper(c))
         str += 'A' + (c - 'A' + shift) % 26;
      else
         str += c;
   }
   return str;
}
std::string caesar_decrypt(std::string_view text, int const shift)
{
   std::string str;
   str.reserve(text.length());
   for (auto const & c : text)
   {
      if (isalpha(c) && isupper(c))
         str += 'A' + (26 + c - 'A' - shift) % 26;
      else
         str += c;
   }
   return str;
}
int main()
{
   auto text = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   for (int i = 1; i <= 26; ++i)
   {
      auto enc = caesar_encrypt(text, i);
      auto dec = caesar_decrypt(enc, i);
      assert(text == dec);
   }
}
```

### 89. Vigenère cipher

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <assert.h>
std::string caesar_encrypt(std::string_view text, int const shift)
{
   std::string str;
   str.reserve(text.length());
   for (auto const & c : text)
   {
      if (isalpha(c) && isupper(c))
         str += 'A' + (c - 'A' + shift) % 26;
      else
         str += c;
   }

   return str;
}
std::string caesar_decrypt(std::string_view text, int const shift)
{
   std::string str;
   str.reserve(text.length());
   for (auto const & c : text)
   {
      if (isalpha(c) && isupper(c))
         str += 'A' + (26 + c - 'A' - shift) % 26;
      else
         str += c;
   }

   return str;
}
std::string build_vigenere_table()
{
   std::string table;
   table.reserve(26*26);
   for (int i = 0; i < 26; ++i)
      table += caesar_encrypt("ABCDEFGHIJKLMNOPQRSTUVWXYZ", i);
   return table;
}
std::string vigenere_encrypt(std::string_view text, std::string_view key)
{
   std::string result;
   result.reserve(text.length());
   static auto table = build_vigenere_table();
   for (size_t i = 0; i < text.length(); ++i)
   {
      auto row = key[i%key.length()] - 'A';
      auto col = text[i] - 'A';
      result += table[row * 26 + col];
   }
   return result;
}
std::string vigenere_decrypt(std::string_view text, std::string_view key)
{
   std::string result;
   result.reserve(text.length());
   static auto table = build_vigenere_table();
   for (size_t i = 0; i < text.length(); ++i)
   {
      auto row = key[i%key.length()] - 'A';
      for (size_t col = 0; col < 26; col++)
      {
         if (table[row * 26 + col] == text[i])
         {
            result += 'A' + col;
            break;
         }
      }
   }
   return result;
}
int main()
{
   auto text = "THECPPCHALLENGER";
   auto enc = vigenere_encrypt(text, "SAMPLE");
   auto dec = vigenere_decrypt(enc, "SAMPLE");
   assert(text == dec);
}
```

### 90. Base64 encoding and decoding

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <assert.h>
class encoder
{
   std::string const table_enc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
   char const padding_symbol = '=';

   char const table_dec[256] =
   {
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,64,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,
      52,53,54,55,56,57,58,59,60,61,-1,-1,-1,65,-1,-1,
      -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
      15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
      -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
      41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
   };
   char const invalid_char = -1;
   char const padding_char = 65;
public:
   std::string to_base64(std::vector<unsigned char> const & data)
   {
      std::string result;
      result.resize((data.size() / 3 + ((data.size() % 3 > 0) ? 1 : 0)) * 4);
      auto result_ptr = &result[0];
      size_t i = 0;
      size_t j = 0;
      while (j++ < data.size() / 3)
      {
         unsigned int value = (data[i] << 16) | (data[i+1] << 8) | data[i+2];
         i += 3;

         *result_ptr++ = table_enc[(value & 0x00fc0000) >> 18];
         *result_ptr++ = table_enc[(value & 0x0003f000) >> 12];
         *result_ptr++ = table_enc[(value & 0x00000fc0) >> 6];
         *result_ptr++ = table_enc[(value & 0x0000003f)];
      };

      auto rest = data.size() - i;
      if (rest == 1)
      {
         *result_ptr++ = table_enc[(data[i] & 0x000000fc) >> 2];
         *result_ptr++ = table_enc[(data[i] & 0x00000003) << 4];
         *result_ptr++ = padding_symbol;
         *result_ptr++ = padding_symbol;
      }
      else if (rest == 2)
      {
         unsigned int value = (data[i] << 8) | data[i + 1];

         *result_ptr++ = table_enc[(value & 0x0000fc00) >> 10];
         *result_ptr++ = table_enc[(value & 0x000003f0) >> 4];
         *result_ptr++ = table_enc[(value & 0x0000000f) << 2];
         *result_ptr++ = padding_symbol;
      }

      return result;
   }

   std::vector<unsigned char> from_base64(std::string data)
   {
      size_t padding = data.size() % 4;
      if (padding == 0)
      {
         if (data[data.size() - 1] == padding_symbol) padding++;
         if (data[data.size() - 2] == padding_symbol) padding++;
      }
      else
      {
         data.append(2, padding_symbol);
      }

      std::vector<unsigned char> result;
      result.resize((data.length() / 4) * 3 - padding);
      auto result_ptr = &result[0];

      size_t i = 0;
      size_t j = 0;
      while (j++ < data.size() / 4)
      {
         unsigned char c1 = table_dec[static_cast<int>(data[i++])];
         unsigned char c2 = table_dec[static_cast<int>(data[i++])];
         unsigned char c3 = table_dec[static_cast<int>(data[i++])];
         unsigned char c4 = table_dec[static_cast<int>(data[i++])];

         if (c1 == invalid_char || c2 == invalid_char ||
             c3 == invalid_char || c4 == invalid_char)
            throw std::runtime_error("invalid base64 encoding");

         if (c4 == padding_char && c3 == padding_char)
         {
            unsigned int value = (c1 << 6) | c2;
            *result_ptr++ = (value >> 4) & 0x000000ff;
         }
         else if (c4 == padding_char)
         {
            unsigned int value = (c1 << 12) | (c2 << 6) | c3;
            *result_ptr++ = (value >> 10) & 0x000000ff;
            *result_ptr++ = (value >> 2) & 0x000000ff;
         }
         else
         {
            unsigned int value = (c1 << 18) | (c2 << 12) | (c3 << 6) | c4;

            *result_ptr++ = (value >> 16) & 0x000000ff;
            *result_ptr++ = (value >> 8) & 0x000000ff;
            *result_ptr++ = value & 0x000000ff;
         }
      }

      return result;
   }
};
struct converter
{
   static std::vector<unsigned char> from_string(std::string_view data)
   {
      std::vector<unsigned char> result;
      std::copy(
         std::begin(data), std::end(data),
         std::back_inserter(result));
      return result;
   }
   static std::string from_range(std::vector<unsigned char> const & data)
   {
      std::string result;
      std::copy(
         std::begin(data), std::end(data),
         std::back_inserter(result));
      return result;
   }
};
int main()
{
   std::vector<std::vector<unsigned char>> data
   {
      { 's' },
      { 's','a' },
      { 's','a','m' },
      { 's','a','m','p' },
      { 's','a','m','p','l' },
      { 's','a','m','p','l','e' },
   };
   encoder enc;
   for (auto const & v : data)
   {
      auto encv = enc.to_base64(v);
      auto decv = enc.from_base64(encv);
      assert(v == decv);
   }
   auto text = "cppchallenge";
   auto textenc = enc.to_base64(converter::from_string(text));
   auto textdec = converter::from_range(enc.from_base64(textenc));
   assert(text == textdec);
}
```

### 91. Validating user credentials

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <iomanip>
#include <vector>
#include "sha.h"
#include "hex.h"
struct user
{
   int id;
   std::string username;
   std::string password;
   std::string firstname;
   std::string lastname;
};
std::string get_hash(std::string_view password)
{
   CryptoPP::SHA512 sha;
   CryptoPP::byte digest[CryptoPP::SHA512::DIGESTSIZE];
   sha.CalculateDigest(
      digest,
      reinterpret_cast<CryptoPP::byte const*>(password.data()),
      password.length());
   CryptoPP::HexEncoder encoder;
   std::string result;
   encoder.Attach(new CryptoPP::StringSink(result));
   encoder.Put(digest, sizeof(digest));
   encoder.MessageEnd();
   return result;
}
int main()
{
   std::vector<user> users
   {
      {
         101, "scarface",
         "07A8D53ADAB635ADDF39BAEACFB799FD7C5BFDEE365F3AA721B7E25B54A4E87D419ADDEA34BC3073BAC472DCF4657E50C0F6781DDD8FE883653D10F7930E78FF",
         "Tony", "Montana"
      },
      {
         202, "neo",
         "C2CC277BCC10888ECEE90F0F09EE9666199C2699922EFB41EA7E88067B2C075F3DD3FBF3CFE9D0EC6173668DD83C111342F91E941A2CADC46A3A814848AA9B05",
         "Thomas", "Anderson"
      },
      {
         303, "godfather",
         "0EA7A0306FE00CD22DF1B835796EC32ACC702208E0B052B15F9393BCCF5EE9ECD8BAAF27840D4D3E6BCC3BB3B009259F6F73CC77480C065DDE67CD9BEA14AA4D",
         "Vito", "Corleone"
      }
   };
   std::string username, password;
   std::cout << "Username: ";
   std::cin >> username;
   std::cout << "Password: ";
   std::cin >> password;
   auto hash = get_hash(password);
   auto pos = std::find_if(
      std::begin(users), std::end(users),
      [username, hash](user const & u) {
      return u.username == username &&
         u.password == hash; });
   if (pos != std::end(users))
      std::cout << "Login successful!" << std::endl;
   else
      std::cout << "Invalid username or password" << std::endl;
}
```

### 92. Computing file hashes

```c++

#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include "sha.h"
#include "md5.h"
#include "hex.h"
#include "files.h"
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
template <class Hash>
std::string compute_hash(fs::path const & filepath)
{
   std::ifstream file(filepath.string(), std::ios::binary);
   if (file.is_open())
   {
      Hash hash;
      CryptoPP::byte digest[Hash::DIGESTSIZE] = { 0 };
      do
      {
         char buffer[4096] = { 0 };
         file.read(buffer, 4096);
         auto extracted = static_cast<size_t>(file.gcount());
         if (extracted > 0)
         {
            hash.Update(
               reinterpret_cast<CryptoPP::byte*>(buffer),
               extracted);
         }
      } while (!file.fail());
      hash.Final(digest);
      CryptoPP::HexEncoder encoder;
      std::string result;
      encoder.Attach(new CryptoPP::StringSink(result));
      encoder.Put(digest, sizeof(digest));
      encoder.MessageEnd();
      return result;
   }
   throw std::runtime_error("Cannot open file!");
}
template <class Hash>
std::string compute_hash_ex(fs::path const & filepath)
{
   std::string digest;
   Hash hash;
   CryptoPP::FileSource source(
      filepath.c_str(),
      true,
      new CryptoPP::HashFilter(hash,
         new CryptoPP::HexEncoder(
            new CryptoPP::StringSink(digest))));
   return digest;
}
int main()
{
   std::string path;
   std::cout << "Path: ";
   std::cin >> path;
   try
   {
      std::cout << "SHA1: "
         << compute_hash<CryptoPP::SHA1>(path) << std::endl;
      std::cout << "SHA256: "
         << compute_hash<CryptoPP::SHA256>(path) << std::endl;
      std::cout << "MD5: "
         << compute_hash<CryptoPP::Weak::MD5>(path) << std::endl;
      std::cout << "SHA1: "
         << compute_hash_ex<CryptoPP::SHA1>(path) << std::endl;
      std::cout << "SHA256: "
         << compute_hash_ex<CryptoPP::SHA256>(path) << std::endl;
      std::cout << "MD5: "
         << compute_hash_ex<CryptoPP::Weak::MD5>(path) << std::endl;
   }
   catch (std::exception const & ex)
   {
      std::cerr << ex.what() << std::endl;
   }
}
```

### 93. Encrypting and decrypting files

```c++

#include <iostream>
#include <string>
#include <string_view>
#include "sha.h"
#include "hex.h"
#include "files.h"
#include "default.h"
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
void encrypt_file(
   fs::path const & sourcefile,
   fs::path const & destfile,
   std::string_view password)
{
   CryptoPP::FileSource source(
      sourcefile.c_str(),
      true,
      new CryptoPP::DefaultEncryptorWithMAC(
      (CryptoPP::byte*)password.data(), password.size(),
         new CryptoPP::FileSink(
            destfile.c_str())
      )
   );
}
void encrypt_file(
   fs::path const & filepath,
   std::string_view password)
{
   auto temppath = fs::temp_directory_path() / filepath.filename();
   encrypt_file(filepath, temppath, password);
   fs::remove(filepath);
   fs::rename(temppath, filepath);
}
void decrypt_file(
   fs::path const & sourcefile,
   fs::path const & destfile,
   std::string_view password)
{
   CryptoPP::FileSource source(
      sourcefile.c_str(),
      true,
      new CryptoPP::DefaultDecryptorWithMAC(
      (CryptoPP::byte*)password.data(), password.size(),
         new CryptoPP::FileSink(
            destfile.c_str())
      )
   );
}
void decrypt_file(
   fs::path const & filepath,
   std::string_view password)
{
   auto temppath = fs::temp_directory_path() / filepath.filename();
   decrypt_file(filepath, temppath, password);
   fs::remove(filepath);
   fs::rename(temppath, filepath);
}
int main()
{
   encrypt_file("sample.txt", "sample.txt.enc", "cppchallenger");
   decrypt_file("sample.txt.enc", "sample.txt.dec", "cppchallenger");
   encrypt_file("sample.txt", "cppchallenger");
   decrypt_file("sample.txt", "cppchallenger");
}
```

### 94. File signing

```c++

#include <iostream>
#include <string>
#include <assert.h>
#include "rsa.h"
#include "aes.h"
#include "hex.h"
#include "files.h"
#include "osrng.h"
#ifdef USE_BOOST_FILESYSTEM
#  include <boost/filesystem/path.hpp>
#  include <boost/filesystem/operations.hpp>
namespace fs = boost::filesystem;
#else
#  include <filesystem>
#  ifdef FILESYSTEM_EXPERIMENTAL
namespace fs = std::experimental::filesystem;
#  else
namespace fs = std::filesystem;
#  endif
#endif
void encode(
   fs::path const & filepath,
   CryptoPP::BufferedTransformation const & bt)
{
   CryptoPP::FileSink file(filepath.c_str());
   bt.CopyTo(file);
   file.MessageEnd();
}
void encode_private_key(
   fs::path const & filepath,
   CryptoPP::RSA::PrivateKey const & key)
{
   CryptoPP::ByteQueue queue;
   key.DEREncodePrivateKey(queue);
   encode(filepath, queue);
}
void encode_public_key(
   fs::path const & filepath,
   CryptoPP::RSA::PublicKey const & key)
{
   CryptoPP::ByteQueue queue;
   key.DEREncodePublicKey(queue);
   encode(filepath, queue);
}
void decode(
   fs::path const & filepath,
   CryptoPP::BufferedTransformation& bt)
{
   CryptoPP::FileSource file(filepath.c_str(), true);
   file.TransferTo(bt);
   bt.MessageEnd();
}
void decode_private_key(
   fs::path const & filepath,
   CryptoPP::RSA::PrivateKey& key)
{
   CryptoPP::ByteQueue queue;
   decode(filepath, queue);
   key.BERDecodePrivateKey(queue, false, queue.MaxRetrievable());
}
void decode_public_key(
   fs::path const & filepath,
   CryptoPP::RSA::PublicKey& key)
{
   CryptoPP::ByteQueue queue;
   decode(filepath, queue);
   key.BERDecodePublicKey(queue, false, queue.MaxRetrievable());
}
void rsa_sign_file(
   fs::path const & filepath,
   fs::path const & privateKeyPath,
   fs::path const & signaturePath,
   CryptoPP::RandomNumberGenerator& rng)
{
   CryptoPP::RSA::PrivateKey privateKey;
   decode_private_key(privateKeyPath, privateKey);
   CryptoPP::RSASSA_PKCS1v15_SHA_Signer signer(privateKey);
   CryptoPP::FileSource fileSource(
      filepath.c_str(),
      true,
      new CryptoPP::SignerFilter(
         rng,
         signer,
         new CryptoPP::FileSink(
            signaturePath.c_str())));
}
bool rsa_verify_file(
   fs::path const & filepath,
   fs::path const & publicKeyPath,
   fs::path const & signaturePath)
{
   CryptoPP::RSA::PublicKey publicKey;
   decode_public_key(publicKeyPath.c_str(), publicKey);
   CryptoPP::RSASSA_PKCS1v15_SHA_Verifier verifier(publicKey);
   CryptoPP::FileSource signatureFile(
      signaturePath.c_str(),
      true);
   if (signatureFile.MaxRetrievable() != verifier.SignatureLength())
      return false;
   CryptoPP::SecByteBlock signature(verifier.SignatureLength());
   signatureFile.Get(signature, signature.size());
   auto* verifierFilter = new CryptoPP::SignatureVerificationFilter(verifier);
   verifierFilter->Put(signature, verifier.SignatureLength());
   CryptoPP::FileSource fileSource(
      filepath.c_str(),
      true,
      verifierFilter);
   return verifierFilter->GetLastResult();
}
void generate_keys(
   fs::path const & privateKeyPath,
   fs::path const & publicKeyPath,
   CryptoPP::RandomNumberGenerator& rng)
{
   try
   {
      CryptoPP::RSA::PrivateKey rsaPrivate;
      rsaPrivate.GenerateRandomWithKeySize(rng, 3072);
      CryptoPP::RSA::PublicKey rsaPublic(rsaPrivate);
      encode_private_key(privateKeyPath, rsaPrivate);
      encode_public_key(publicKeyPath, rsaPublic);
   }
   catch (CryptoPP::Exception const & e)
   {
      std::cerr << e.what() << std::endl;
   }
}
int main()
{
   CryptoPP::AutoSeededRandomPool rng;
   generate_keys(
      "rsa-private.key",
      "rsa-public.key",
      rng);
   rsa_sign_file(
      "sample.txt",
      "rsa-private.key",
      "sample.sign",
      rng);
   auto success = rsa_verify_file(
      "sample.txt",
      "rsa-public.key",
      "sample.sign");
   assert(success);
}
```

## Networking and Services

### 95. Finding the IP address of a host

```c++

#include <iostream>
#include <vector>
#include <string>
#include <string_view>
#define ASIO_STANDALONE
#include "asio.hpp"
std::vector<std::string> get_ip_address(std::string_view hostname)
{
   std::vector<std::string> ips;
   try
   {
      asio::io_context context;
      asio::ip::tcp::resolver resolver(context);
      auto endpoints = resolver.resolve(asio::ip::tcp::v4(), hostname.data(), "");
      for (auto e = endpoints.begin(); e != endpoints.end(); ++e)
         ips.push_back(((asio::ip::tcp::endpoint)*e).address().to_string());
   }
   catch (std::exception const & e)
   {
      std::cerr << "exception: " << e.what() << std::endl;
   }
   return ips;
}
int main()
{
   auto ips = get_ip_address("packtpub.com");
   for (auto const & ip : ips)
      std::cout << ip << std::endl;
}
```

### 96. Client-server Fizz-Buzz

```c++
#include <iostream>
#include <string>

#define ASIO_STANDALONE
#include "asio.hpp"

std::string fizzbuzz(int const number)
{
   if (number != 0)
   {
      auto m3 = number % 3;
      auto m5 = number % 5;
      if (m3 == 0 && m5 == 0) return "fizzbuzz";
      else if (m5 == 0) return "buzz";
      else if (m3 == 0) return "fizz";
   }

   return std::to_string(number);
}

class session : public std::enable_shared_from_this<session>
{
public:
   session(asio::ip::tcp::socket socket) : 
      tcp_socket(std::move(socket))
   {
   }

   void start()
   {
      read();
   }

private:
   void read()
   {
      auto self(shared_from_this());

      tcp_socket.async_read_some(
         asio::buffer(data, data.size()),
         [this, self](std::error_code const ec, std::size_t const length)
      {
         if (!ec)
         {
            auto number = std::string(data.data(), length);
            auto result = fizzbuzz(std::atoi(number.c_str()));

            std::cout << number << " -> " << result << std::endl;

            write(result);
         }
      });
   }

   void write(std::string_view response)
   {
      auto self(shared_from_this());

      tcp_socket.async_write_some(
         asio::buffer(response.data(), response.length()),
         [this, self](std::error_code const ec, std::size_t const)
      {
         if (!ec)
         {
            read();
         }
      });
   }

   std::array<char, 1024>  data;
   asio::ip::tcp::socket   tcp_socket;
};

class server
{
public:
   server(asio::io_context& context, short const port)
      : tcp_acceptor(context, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))
      , tcp_socket(context)
   {
      std::cout << "server running on port " << port << std::endl;

      accept();
   }

private:
   void accept()
   {
      tcp_acceptor.async_accept(tcp_socket, [this](std::error_code ec)
      {
         if (!ec)
         {
            std::make_shared<session>(std::move(tcp_socket))->start();
         }

         accept();
      });
   }

   asio::ip::tcp::acceptor tcp_acceptor;
   asio::ip::tcp::socket   tcp_socket;
};

void run_server(short const port)
{
   try
   {
      asio::io_context context;

      server srv(context, port);

      context.run();
   }
   catch (std::exception const & e)
   {
      std::cerr << "exception: " << e.what() << std::endl;
   }
}

int main()
{
   run_server(11234);
}

```

```c++

#include <iostream>
#include <array>
#define ASIO_STANDALONE
#include "asio.hpp"
void run_client(std::string_view host, short const port)
{
   try
   {
      asio::io_context context;
      asio::ip::tcp::socket tcp_socket(context);
      asio::ip::tcp::resolver resolver(context);
      asio::connect(tcp_socket, 
                    resolver.resolve({ host.data(), std::to_string(port) }));
      while (true)
      {
         std::cout << "number [1-99]: ";
         int number;
         std::cin >> number;
         if (std::cin.fail() || number < 1 || number > 99)
            break;
         auto request = std::to_string(number);
         tcp_socket.write_some(asio::buffer(request, request.length()));
         std::array<char, 1024> reply;
         auto reply_length = tcp_socket.read_some(asio::buffer(reply, reply.size()));
         std::cout << "reply is: ";
         std::cout.write(reply.data(), reply_length);
         std::cout << std::endl;
      }
   }
   catch (std::exception const & e)
   {
      std::cerr << "exception: " << e.what() << std::endl;
   }
}
int main()
{
   run_client("localhost", 11234);
}
```

### 97. Bitcoin exchange rates

```c++

#include <iostream>
#include <ostream>
#include <string>
#include <string_view>
#include <map>
#include "curl_easy.h"
#include "curl_exception.h"
#include "json.hpp"
using json = nlohmann::json;
struct exchange_info
{
   double delay_15m_price;
   double latest_price;
   double buying_price;
   double selling_price;
   std::string symbol;
};
using blockchain_rates = std::map<std::string, exchange_info>;
void from_json(const json& jdata, exchange_info& info)
{
   info.delay_15m_price = jdata.at("15m").get<double>();
   info.latest_price = jdata.at("last").get<double>();
   info.buying_price = jdata.at("buy").get<double>();
   info.selling_price = jdata.at("sell").get<double>();
   info.symbol = jdata.at("symbol").get<std::string>();
}
std::stringstream get_json_document(std::string_view url)
{
   std::stringstream str;
   try 
   {
      curl::curl_ios<std::stringstream> writer(str);
      curl::curl_easy easy(writer);
      easy.add<CURLOPT_URL>(url.data());
      easy.add<CURLOPT_FOLLOWLOCATION>(1L);
      easy.perform();
   }
   catch (curl::curl_easy_exception const & error) 
   {
      auto errors = error.get_traceback();
      error.print_traceback();
   }

   return str;
}
int main() 
{
   auto doc = get_json_document("https://blockchain.info/ticker");
   json jdata;
   doc >> jdata;
   blockchain_rates rates = jdata;
   for (auto const & kvp : rates)
   {
      std::cout << "1BPI = " << kvp.second.latest_price 
                << " " << kvp.first << std::endl;
   }
}
```

### 98. Fetching emails using IMAP

```c++

#include <iostream>
#include <string>
#include <string_view>
#include "curl_easy.h"
#include "curl_exception.h"
class imap_connection
{
public:
   imap_connection(
      std::string_view url,
      unsigned short const port,
      std::string_view user,
      std::string_view pass):
      url(url), port(port), user(user), pass(pass)
   {
   }
   std::string get_folders()
   {
      std::stringstream str;
      try
      {
         curl::curl_ios<std::stringstream> writer(str);
         curl::curl_easy easy(writer);
         easy.add<CURLOPT_URL>(url.data());
         setup_easy(easy);
         easy.perform();
      }
      catch (curl::curl_easy_exception const & error)
      {
         auto errors = error.get_traceback();
         error.print_traceback();
      }
      return str.str();
   }
   std::string examine_folder(std::string_view folder)
   {
      std::stringstream str;
      try
      {
         curl::curl_ios<std::stringstream> writer(str);
         curl::curl_easy easy(writer);
         easy.add<CURLOPT_URL>(url.data());
         easy.add<CURLOPT_CUSTOMREQUEST>((std::string("EXAMINE ") + folder.data()).c_str());
         setup_easy(easy);
         easy.perform();
      }
      catch (curl::curl_easy_exception const & error)
      {
         auto errors = error.get_traceback();
         error.print_traceback();
      }
      return str.str();
   }
   std::vector<unsigned int> fetch_unread_uids(std::string_view folder)
   {
      std::stringstream str;
      try
      {
         curl::curl_ios<std::stringstream> writer(str);
         curl::curl_easy easy(writer);
         easy.add<CURLOPT_URL>((url.data() + std::string("/") + folder.data() + std::string("/")).c_str());
         easy.add<CURLOPT_CUSTOMREQUEST>("SEARCH UNSEEN");
         setup_easy(easy);
         easy.perform();
      }
      catch (curl::curl_easy_exception const & error)
      {
         auto errors = error.get_traceback();
         error.print_traceback();
      }
      std::vector<unsigned int> uids;
      str.seekg(8, std::ios::beg);
      unsigned int uid;
      while (str >> uid)
         uids.push_back(uid);
      return uids;
   }
   std::string fetch_email(std::string_view folder, unsigned int uid)
   {
      std::stringstream str;
      try
      {
         curl::curl_ios<std::stringstream> writer(str);
         curl::curl_easy easy(writer);
         easy.add<CURLOPT_URL>((url.data() + std::string("/") + folder.data() + std::string("/;UID=") + std::to_string(uid)).c_str());
         setup_easy(easy);
         easy.perform();
      }
      catch (curl::curl_easy_exception error)
      {
         auto errors = error.get_traceback();
         error.print_traceback();
      }
      return str.str();
   }
private:
   void setup_easy(curl::curl_easy& easy)
   {
      easy.add<CURLOPT_PORT>(port);
      easy.add<CURLOPT_USERNAME>(user.c_str());
      easy.add<CURLOPT_PASSWORD>(pass.c_str());
      easy.add<CURLOPT_USE_SSL>(CURLUSESSL_ALL);
      easy.add<CURLOPT_SSL_VERIFYPEER>(0L);
      easy.add<CURLOPT_SSL_VERIFYHOST>(0L);
      easy.add<CURLOPT_USERAGENT>("libcurl-agent/1.0");
   }
private:
   std::string    url;
   unsigned short port;
   std::string    user;
   std::string    pass;
};
int main()
{
   imap_connection imap(
      "imaps://imap.gmail.com",
      993,
      "...(your username)...",
      "...(your password)...");
   auto folders = imap.get_folders();
   std::cout << folders << std::endl;
   auto info = imap.examine_folder("inbox");
   std::cout << info << std::endl;
   auto uids = imap.fetch_unread_uids("inbox");
   if (!uids.empty())
   {
      auto email = imap.fetch_email("inbox", uids.back());
      std::cout << email << std::endl;
   }
   return 0;
}
```

### 99. Translating text to any language

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <regex>
#include <codecvt>
#include <iostream>
#include <locale>
#include <memory>
#include <vector>
#include <tuple>
#include "curl_easy.h"
#include "curl_exception.h"
#include "curl_header.h"
std::wstring utf8_to_utf16(std::string_view text)
{
   std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
   std::wstring wtext = converter.from_bytes(text.data());
   return wtext;
}
std::string utf16_to_utf8(std::wstring_view wtext)
{
   std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
   std::string text = converter.to_bytes(wtext.data());
   return text;
}
class text_translator
{
public:
   text_translator(std::string_view endpoint, 
                   std::string_view key) 
      : endpoint(endpoint), app_key(key)
   {}
   std::wstring translate_text(
      std::wstring_view wtext, 
      std::string_view to,
      std::string_view from = "en")
   {
      try
      {
         using namespace std::string_literals;
         std::stringstream str;
         std::string text = utf16_to_utf8(wtext);
         curl::curl_ios<std::stringstream> writer(str);
         curl::curl_easy easy(writer);
         curl::curl_header header;
         header.add("Ocp-Apim-Subscription-Key:" + app_key);
         easy.escape(text);
         auto url = endpoint + "/Translate";
         url += "?from="s + from.data();
         url += "&to="s + to.data();
         url += "&text="s + text;
         easy.add<CURLOPT_URL>(url.c_str());
         easy.add<CURLOPT_HTTPHEADER>(header.get());
         easy.perform();
         auto result = deserialize_result(str.str());
         return utf8_to_utf16(result);
      }
      catch (curl::curl_easy_exception const & error)
      {
         auto errors = error.get_traceback();
         error.print_traceback();
      }
      catch (std::exception const & ex)
      {
         std::cout << ex.what() << std::endl;
      }
      return {};
   }
private:
   std::string deserialize_result(std::string_view text)
   {
      std::regex rx(R"(<string.*>(.*)<\/string>)");
      std::cmatch match;
      if (std::regex_search(text.data(), match, rx))
      {
         return match[1];
      }
      return "";
   }
   std::string endpoint;
   std::string app_key;
};
void set_utf8_conversion(std::wostream& stream)
{
   auto codecvt = std::make_unique<std::codecvt_utf8<wchar_t>>();
   std::locale utf8locale(std::locale(), codecvt.get());
   codecvt.release();
   stream.imbue(utf8locale);
}
int main()
{
#ifdef _WIN32
   SetConsoleOutputCP(CP_UTF8);
#endif
   set_utf8_conversion(std::wcout);
   text_translator tt(
      "https://api.microsofttranslator.com/V2/Http.svc",
      "...(your api key)...");
   std::vector<std::tuple<std::wstring, std::string, std::string>> texts
   {
      { L"hello world!", "en", "ro"},
      { L"what time is it?", "en", "es" },
      { L"ceci est un exemple", "fr", "en" }
   };
   for (auto const [text, from, to] : texts)
   {
      auto result = tt.translate_text(text, to, from);
      std::cout << from << ": "; 
      std::wcout << text << std::endl;
      std::cout << to << ": ";
      std::wcout << result << std::endl;
   }
}
```

### 100. Detecting faces in a picture

```c++

#include <iostream>
#include <string>
#include <string_view>
#include <fstream>
#include "curl_easy.h"
#include "curl_exception.h"
#include "curl_header.h"
#include "json.hpp"
using json = nlohmann::json;
std::vector<uint8_t> load_image(std::string_view filepath)
{
   std::vector<uint8_t> data;
   std::ifstream ifile(filepath.data(), std::ios::binary | std::ios::ate);
   if (ifile.is_open())
   {
      auto size = ifile.tellg();
      ifile.seekg(0, std::ios::beg);
      data.resize(static_cast<size_t>(size));
      ifile.read(reinterpret_cast<char*>(data.data()), size);
   }
   return data;
}
struct face_rectangle
{
   int width = 0;
   int height = 0;
   int left = 0;
   int top = 0;
};
struct face_point
{
   double x = 0;
   double y = 0;
};
struct face_landmarks
{
   face_point pupilLeft;
   face_point pupilRight;
   face_point noseTip;
   face_point mouthLeft;
   face_point mouthRight;
   face_point eyebrowLeftOuter;
   face_point eyebrowLeftInner;
   face_point eyeLeftOuter;
   face_point eyeLeftTop;
   face_point eyeLeftBottom;
   face_point eyeLeftInner;
   face_point eyebrowRightInner;
   face_point eyebrowRightOuter;
   face_point eyeRightInner;
   face_point eyeRightTop;
   face_point eyeRightBottom;
   face_point eyeRightOuter;
   face_point noseRootLeft;
   face_point noseRootRight;
   face_point noseLeftAlarTop;
   face_point noseRightAlarTop;
   face_point noseLeftAlarOutTip;
   face_point noseRightAlarOutTip;
   face_point upperLipTop;
   face_point upperLipBottom;
   face_point underLipTop;
   face_point underLipBottom;
};
struct face_emotion
{
   double anger = 0;
   double contempt = 0;
   double disgust = 0;
   double fear = 0;
   double happiness = 0;
   double neutral = 0;
   double sadness = 0;
   double surprise = 0;
};
struct face_attributes
{
   std::string  gender;
   double       age;
   face_emotion emotion;
};
struct face_info
{
   std::string     faceId;
   face_rectangle  rectangle;
   face_landmarks  landmarks;
   face_attributes attributes;
};
struct face_error
{
   std::string code;
   std::string message;
};
struct face_error_response
{
   face_error error;
};
using face_detect_response = std::vector<face_info>;
void from_json(const json& jdata, face_rectangle& rect)
{
   rect.width = jdata.at("width").get<int>();
   rect.height = jdata.at("height").get<int>();
   rect.top = jdata.at("top").get<int>();
   rect.left = jdata.at("left").get<int>();
}
void from_json(const json& jdata, face_point& point)
{
   point.x = jdata.at("x").get<double>();
   point.y = jdata.at("y").get<double>();
}
void from_json(const json& jdata, face_landmarks& mark)
{
   mark.pupilLeft = jdata.at("pupilLeft");
   mark.pupilRight = jdata.at("pupilRight");
   mark.noseTip = jdata.at("noseTip");
   mark.mouthLeft = jdata.at("mouthLeft");
   mark.mouthRight = jdata.at("mouthRight");
   mark.eyebrowLeftOuter = jdata.at("eyebrowLeftOuter");
   mark.eyebrowLeftInner = jdata.at("eyebrowLeftInner");
   mark.eyeLeftOuter = jdata.at("eyeLeftOuter");
   mark.eyeLeftTop = jdata.at("eyeLeftTop");
   mark.eyeLeftBottom = jdata.at("eyeLeftBottom");
   mark.eyeLeftInner = jdata.at("eyeLeftInner");
   mark.eyebrowRightInner = jdata.at("eyebrowRightInner");
   mark.eyebrowRightOuter = jdata.at("eyebrowRightOuter");
   mark.eyeRightInner = jdata.at("eyeRightInner");
   mark.eyeRightTop = jdata.at("eyeRightTop");
   mark.eyeRightBottom = jdata.at("eyeRightBottom");
   mark.eyeRightOuter = jdata.at("eyeRightOuter");
   mark.noseRootLeft = jdata.at("noseRootLeft");
   mark.noseRootRight = jdata.at("noseRootRight");
   mark.noseLeftAlarTop = jdata.at("noseLeftAlarTop");
   mark.noseRightAlarTop = jdata.at("noseRightAlarTop");
   mark.noseLeftAlarOutTip = jdata.at("noseLeftAlarOutTip");
   mark.noseRightAlarOutTip = jdata.at("noseRightAlarOutTip");
   mark.upperLipTop = jdata.at("upperLipTop");
   mark.upperLipBottom = jdata.at("upperLipBottom");
   mark.underLipTop = jdata.at("underLipTop");
   mark.underLipBottom = jdata.at("underLipBottom");
}
void from_json(const json& jdata, face_emotion& emo)
{
   emo.anger = jdata.at("anger").get<double>();
   emo.contempt = jdata.at("contempt").get<double>();
   emo.disgust = jdata.at("disgust").get<double>();
   emo.fear = jdata.at("fear").get<double>();
   emo.happiness = jdata.at("happiness").get<double>();
   emo.neutral = jdata.at("neutral").get<double>();
   emo.sadness = jdata.at("sadness").get<double>();
   emo.surprise = jdata.at("surprise").get<double>();
}
void from_json(const json& jdata, face_attributes& attr)
{
   attr.age = jdata.at("age").get<double>();
   attr.emotion = jdata.at("emotion");
   attr.gender = jdata.at("gender").get<std::string>();
}
void from_json(const json& jdata, face_info& info)
{
   info.faceId = jdata.at("faceId").get<std::string>();
   info.attributes = jdata.at("faceAttributes");
   info.landmarks = jdata.at("faceLandmarks");
   info.rectangle = jdata.at("faceRectangle");
}
void from_json(const json& jdata, face_error& error)
{
   error.code = jdata.at("code").get<std::string>();
   error.message = jdata.at("message").get<std::string>();
}
void from_json(const json& jdata, face_error_response& response)
{
   response.error = jdata.at("error");
}
class face_manager
{
public:
   face_manager(std::string_view endpoint, 
                std::string_view key) 
      : endpoint(endpoint), app_key(key)
   {}
   face_detect_response detect_from_file(std::string_view path)
   {
      try
      {
         auto data = load_image(path);
         if (!data.empty())
         {
            std::stringstream str;
            curl::curl_ios<std::stringstream> writer(str);
            curl::curl_easy easy(writer);
            curl::curl_header header;
            header.add("Ocp-Apim-Subscription-Key:" + app_key);
            header.add("Content-Type:application/octet-stream");
            auto url = endpoint +
               "/detect"
               "?returnFaceId=true"
               "&returnFaceLandmarks=true"
               "&returnFaceAttributes=age,gender,emotion";
            easy.add<CURLOPT_URL>(url.c_str());
            easy.add<CURLOPT_HTTPHEADER>(header.get());
            easy.add<CURLOPT_POSTFIELDSIZE>(data.size());
            easy.add<CURLOPT_POSTFIELDS>(reinterpret_cast<char*>(data.data()));
            easy.perform();
            auto status = easy.get_info<CURLINFO_RESPONSE_CODE>();
            return parse_detect_response(status.get(), str);
         }
      }
      catch (curl::curl_easy_exception const & error)
      {
         auto errors = error.get_traceback();
         error.print_traceback();
      }
      catch (std::exception const & ex)
      {
         std::cout << ex.what() << std::endl;
      }
      return {};
   }
private:
   face_detect_response parse_detect_response(
      long const status, 
      std::stringstream & str)
   {
      json jdata;
      str >> jdata;
      try
      {
         if (status == 200)
         {
            face_detect_response response = jdata;
            return response;
         }
         else if (status >= 400)
         {
            face_error_response response = jdata;
            std::cout << response.error.code << std::endl
               << response.error.message << std::endl;
         }
      }
      catch (std::exception const & ex) 
      {
         std::cout << ex.what() << std::endl;
      }
      return {};
   }
   std::string endpoint;
   std::string app_key;
};
int main()
{
   face_manager manager(
      "https://westeurope.api.cognitive.microsoft.com/face/v1.0",
      "...(your api key)...");

#ifdef _WIN32
   std::string path = R"(res\albert_and_elsa.jpg)";
#else
   std::string path = R"(./res/albert_and_elsa.jpg)";
#endif
   auto results = manager.detect_from_file(path);
   for (auto const & face : results)
   {
      std::cout << "faceId: " << face.faceId << std::endl
                << "age:    " << face.attributes.age << std::endl
                << "gender: " << face.attributes.gender << std::endl
                << "rect:   " << "{" << face.rectangle.left 
                              << "," << face.rectangle.top
                              << "," << face.rectangle.width
                              << "," << face.rectangle.height
                              << "}" << std::endl << std::endl;
   }
}
```